```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load packages

```{r}
library(harmony)
library(DropletUtils)
library(Seurat)
library(tidyverse)
library(dplyr)
library(stringr)
library(knitr)
library(DoubletFinder)
library(SoupX)
library(scCustomize)
library(DESeq2)
# library(devtools)
# install_github("immunogenomics/harmony")
```

## Second draft of integration script (first in log33)

```{r}
#Load all of the relevant data. This will be soup-less, doublet-filtered Seruat objects from each paper

load("Rdata/Ver_singlets_merged.RData")
load("Rdata/Xim_singlets_mergedRedux.Rdata") #Using Redux info (from new reference)
load("Rdata/Slo_singlets_merged.RData")
Slo_singlets_merged<-Slota_singlets_merged
rm(Slota_singlets_merged)
gc()
#What would the size of this be in memory?
  #33.75 GB

#Set active assays to RNA
DefaultAssay(Slo_singlets_merged) <- "RNA"
DefaultAssay(Xim_singlets_merged) <- "RNA"
DefaultAssay(Ver_singlets_merged) <- "RNA"
```

## Need ot subset the astrocytes from each dataset first....?

## Add metadata about treatment

```{r}
#Add metadata on treatment, adapted from Chat GPT
#Slota
sampleLabs_Slota<- names(Slo_singlets_merged@active.ident)

treat_detect_Slota <- case_when(
  str_detect(sampleLabs_Slota, "RML.*HP*") ~ "RML_HP",
  str_detect(sampleLabs_Slota, "PBS.*HP*") ~ "PBS_HP",
  str_detect(sampleLabs_Slota, "RML.*CX*") ~ "RML_CX",
  str_detect(sampleLabs_Slota, "PBS.*CX*") ~ "PBS_CX",
  TRUE ~ NA_character_
)

Slo_singlets_merged@meta.data$treatment<-treat_detect_Slota
Idents(object=Slo_singlets_merged)<-"treatment"
rm(treat_detect_Slota, sampleLabs_Slota)
table(Slo_singlets_merged$treatment)

#Ximerakis
sampleLabs_Xim<- names(Xim_singlets_merged@active.ident)

treat_detect_Xim <- case_when(
  str_detect(sampleLabs_Xim, "OX*") ~ "AGED",
  str_detect(sampleLabs_Xim, "YX*") ~ "YOUNG",
  TRUE ~ NA_character_
)

Xim_singlets_merged@meta.data$treatment<-treat_detect_Xim
Idents(object=Xim_singlets_merged)<-"treatment"
rm(treat_detect_Xim, sampleLabs_Xim)

#Verity
sampleLabs_Verity<-names(Ver_singlets_merged@active.ident)

#From Chat GPT
treat_detect_Verity <- case_when(
  str_detect(sampleLabs_Verity, "sample11") ~ "AGEING",
  str_detect(sampleLabs_Verity, "sample1") ~ "NBH",
  str_detect(sampleLabs_Verity, "sample2") ~ "NBH",
  str_detect(sampleLabs_Verity, "sample5") ~ "ME7",
  str_detect(sampleLabs_Verity, "sample6") ~ "ME7",
  str_detect(sampleLabs_Verity, "sample9") ~ "AGEING",
  TRUE ~ NA_character_
)
#
Ver_singlets_merged@meta.data$treatment<-treat_detect_Verity

#FIXME may not be needed if the integration workflow specifies what to consider anyway
Idents(object=Ver_singlets_merged)<-"treatment"
rm(sampleLabs_Verity, treat_detect_Verity)

gc()
```

```{r}
#split, then subset and merge the relevant data into the comparison datasets as detailed in the comparison table above
Xim_list<-SplitObject(Xim_singlets_merged, split.by = "treatment")
Slo_list<-SplitObject(Slo_singlets_merged, split.by = "treatment")
Ver_list<-SplitObject(Ver_singlets_merged, split.by = "treatment")
rm(Xim_singlets_merged, Slo_singlets_merged, Ver_singlets_merged)
gc()
```

```{r}
#COMPARISON 1 Hippocampus DEG between datasets (Verity and terminal)
#list of samples to merge
comp1<-c(Slo_list$PBS_HP,Slo_list$RML_HP,Ver_list$NBH, Ver_list$ME7)

# Merge raw samples, adapted from here https://hbctraining.github.io/scRNA-seq_online/lessons/06a_integration_harmony.html
comp1_merged <-Merge_Seurat_List(list_seurat=comp1)

rm(comp1)
gc()

# Perform log-normalization and feature selection, as well as SCT normalization on global object
comp1_merged <- comp1_merged %>%
    NormalizeData() %>%
    FindVariableFeatures(selection.method = "vst", nfeatures = 2000) %>% 
    ScaleData() #%>%
    #SCTransform(vars.to.regress = c("mitoRatio")) #FIXME do we need this?

# Calculate PCs using variable features determined by SCTransform (3000 by default) ##I have changed the assay to RNA and reduced pcs to 30 from 50
#Visualise the data
comp1_merged <- RunPCA(comp1_merged, assay = "RNA", npcs = 30)
#Elbowplot shows around 20 PCs are enough

comp1_merged<- RunUMAP(comp1_merged, reduction = "pca", dims = 1:20)
DimPlot(comp1_merged, reduction='umap', group.by = 'treatment', raster=F)+ggtitle("Verity and Slota Hippocampal data", subtitle = "Before harmony integration")

#Add proper sample labels




comp1_harmonized <- RunHarmony(comp1_merged, group.by.vars = c("treatment"), #FIXME variable names to integrate on
				reduction = "pca", assay.use = "RNA", reduction.save = "harmony", verbose=T)

comp1_harmonized <- 
  RunUMAP(comp1_harmonized, reduction = "harmony", dims = 1:20) %>%
  FindNeighbors(reduction='harmony', dims=1:20) %>%
  FindClusters(resolution=c(0.2,0.3,0.5,0.7,1))

#This gives a good level of clustering 
comp1_harmonized@active.ident<-comp1_harmonized@meta.data$RNA_snn_res.0.3

#Visualisation
# dimplotcolours=c(
#   'NA',
#   rgb(0.53, 0.81, 0.95, 0.5),
#   rgb(0.23, 0.51, 0.75, 0.5), #uncomment to give sample 11 colour, but this covers most of the data
#   rgb(0.95, 0.27, 0.14, 0.5)
#   
# )


DimPlot(comp1_harmonized, raster=F, group.by = 'treatment')+ggtitle("Verity and Slota Hippocampal Astrocyte data", subtitle = "After harmony integration")#+scale_color_manual(values = dimplotcolours)

```

```{r}
#Version2 astrocytes only

load("Rdata/Slota.self_integrated_RPCA.Rdata")
load("Rdata/Verity.self_integrated_RPCA_NBHME7.Rdata")

library(SingleR)
library(celldex)
mouse.ref <- celldex::MouseRNAseqData()
sce <- as.SingleCellExperiment(Verity.combinedNBHME7)
mouse.main <- SingleR(test=sce, ref=mouse.ref, labels=mouse.ref$label.main, de.method="wilcox")
mouse.fine <- SingleR(test=sce, ref=mouse.ref, labels=mouse.ref$label.fine, de.method="wilcox")
table(mouse.fine$labels)
# https://github.com/LTLA/SingleR/blob/master/README.md
#Add annotation back to Seruat object
Verity.combinedNBHME7[["SingleR.labels.main"]] <- mouse.main$labels
Verity.combinedNBHME7[["SingleR.labels.fine"]] <- mouse.fine$labels
Verity.combinedNBHME7 <- SetIdent(Verity.combinedNBHME7, value = "SingleR.labels.fine")
rm(sce, mouse.fine, mouse.main, mouse.ref)
#Visualise distribution on UMAP
DimPlot(Verity.combinedNBHME7, label = T , repel = T, label.size = 3, raster=F, split.by = 'treatment')
View(Verity.combined)
# Convert cluster names to character
Idents(Verity.combinedNBHME7) <- as.character(Idents(Verity.combinedNBHME7))
VlnPlot(Verity.combinedNBHME7, features = "Gfap")
#Subset out astrocytes
Ver_astrocytes<-subset(Verity.combinedNBHME7, idents=c('Astrocytes', 'Astrocytes activated'))

sce <- as.SingleCellExperiment(Slota.combined)
mouse.main <- SingleR(test=sce, ref=mouse.ref, labels=mouse.ref$label.main, de.method="wilcox")
mouse.fine <- SingleR(test=sce, ref=mouse.ref, labels=mouse.ref$label.fine, de.method="wilcox")
table(mouse.fine$labels)
# https://github.com/LTLA/SingleR/blob/master/README.md
#Add annotation back to Seruat object
Slota.combined[["SingleR.labels.main"]] <- mouse.main$labels
Slota.combined[["SingleR.labels.fine"]] <- mouse.fine$labels
Slota.combined <- SetIdent(Slota.combined, value = "SingleR.labels.fine")
rm(sce, mouse.fine, mouse.main, mouse.ref)
#Visualise distribution on UMAP
DimPlot(Slota.combined, label = T , repel = T, label.size = 3, raster=F)+ggtitle("Slota dataset integrated clustering", subtitle="Cell annotation with SingleR")
# Convert cluster names to character
Idents(Slota.combined) <- as.character(Idents(Slota.combined))
VlnPlot(Slota.combined, features = "Slc1a2")
#Subset out astrocytes
Slo_astrocytes<-subset(Slota.combined, idents=c('Astrocytes', 'Astrocytes activated'))
#Show the data membership acorss cell type in the astrocyte set
table(Slo_astrocytes$treatment)
table(Slo_astrocytes$SingleR.labels.fine)

Slo_list<-SplitObject(Slo_astrocytes, split.by = "treatment")
Ver_list<-SplitObject(Ver_astrocytes, split.by = "treatment")
#COMPARISON 1 Hippocampus DEG between datasets (Verity and terminal)
#list of samples to merge
comp1<-c(Slo_list$PBS_HP,Slo_list$RML_HP,Ver_list$NBH, Ver_list$ME7)

# Merge raw samples, adapted from here https://hbctraining.github.io/scRNA-seq_online/lessons/06a_integration_harmony.html
comp1_merged <-Merge_Seurat_List(list_seurat=comp1)

DefaultAssay(comp1_merged)<-'RNA'
comp1_merged <- comp1_merged %>%
NormalizeData() %>%
FindVariableFeatures(selection.method = "vst", nfeatures = 2000) %>%
ScaleData() #%>%

# Calculate PCs using variable features determined by SCTransform (3000 by default) ##I have changed the assay to RNA and reduced pcs to 30 from 50
#Visualise the data
comp1_merged <- RunPCA(comp1_merged, assay = "RNA", npcs = 30)

#Elbowplot shows around 20 PCs are enough
comp1_merged<- RunUMAP(comp1_merged, reduction = "pca", dims = 1:20)
DimPlot(comp1_merged, reduction='umap', group.by = 'treatment', raster=F)+ggtitle("Verity and Slota Hippocampal data", subtitle = "Before harmony integration")
#Add proper sample labels
comp1_harmonized <- RunHarmony(comp1_merged, group.by.vars = c("treatment"), #FIXME variable names to integrate on
reduction = "pca", assay.use = "RNA", reduction.save = "harmony", verbose=T)
comp1_harmonized <-
RunUMAP(comp1_harmonized, reduction = "harmony", dims = 1:20) %>%
FindNeighbors(reduction='harmony', dims=1:20) %>%
FindClusters(resolution=c(0.2,0.3,0.5,0.7,1))
#This gives a good level of clustering
comp1_harmonized@active.ident<-comp1_harmonized@meta.data$RNA_snn_res.0.3
#Visualisation

DimPlot(comp1_merged, reduction='umap', group.by = 'treatment', raster=F)+ggtitle("Verity and Slota Hippocampal Astrocyte data", subtitle = "Before harmony integration")

DimPlot(comp1_harmonized, raster=F, group.by = 'treatment')+ggtitle("Verity and Slota Hippocampal Astrocyte data", subtitle = "After harmony integration")

```

## Add annotation from ensembl for gene description, ensembl ID and chromosome location

```{r}
# load the markers for Verity
# load("Rdata/Verity_astrocyte_prion.markers_defaults_Redux.RData")
# 
# #load the markers for Slota Hippocampus
# load("Rdata/Slota_astrocyte_prion.markers_Redux.RData")
# load("Rdata/Slota_astrocyte_prion.markers_CX_Redux.RData")


#filter the data so that avg_log2FC > 0.5, p_val_adj<0.05
DEG_data_Verity_Slota<-list(Slota_astrocyte_prion.markers_CX,Slota_astrocyte_prion.markers,Verity_astrocyte_prion.markers_defaults)

DEG_data_Verity_Slota <- lapply(DEG_data_Verity_Slota, function(DEG_part) {
  DEG_part$gene<-rownames(DEG_part)
  return(DEG_part)
})

#Adapted from http://girke.bioinformatics.ucr.edu/CSHL_RNAseq/mydoc/mydoc_systemPipeRNAseq_07/
#Get annotation info
library("biomaRt")
m <- useMart("ensembl", dataset="mmusculus_gene_ensembl")

DEG_data_Verity_Slota <- lapply(DEG_data_Verity_Slota, function(DEG_part) {
  #store gene names and use them
  print(DEG_part[1,])
  DEG_part$gene<-rownames(DEG_part)
  gene_ids <- unique(DEG_data_Verity_Slota[[1]]$gene)
  
  #get relevant info from the mart
  gene_info <- getBM(attributes = c("ensembl_gene_id", "external_gene_name", "description","chromosome_name"), filters = "external_gene_name", values = gene_ids, mart = m)
  
  #apply the info to the gene list
  DEG_part <- merge(DEG_part, gene_info, by.x = "gene", by.y = "external_gene_name", all.x = TRUE)
  
  return(DEG_part)  # Return the modified data frame
})

#Save the dataset's annotated genes

write.csv(DEG_data_Verity_Slota[[3]], file = "Verity_DGEs_ME7vNBH.csv")
write.csv(DEG_data_Verity_Slota[[2]], file = "Slota_DGEs_HP_RMLvPBS.csv")
write.csv(DEG_data_Verity_Slota[[1]], file = "Slota_DGEs_CX_RMLvPBS.csv")

```

## VennDiagram prep

```{r}


#Plot raw list

DEG_names_SLota_CX_RAW<-(DEG_data_Verity_Slota[[1]]$gene)
DEG_names_SLota_HP_RAW<-(DEG_data_Verity_Slota[[2]]$gene)
DEG_names_Verity_RAW<-(DEG_data_Verity_Slota[[3]]$gene)

library(gplots)
# Create a Venn-diagram given just the list of gene-names for both sets
venn_diagram_RAW <- venn(list("Verity_HP" = DEG_names_Verity_RAW,
                          "SlotA_HP" = DEG_names_SLota_HP_RAW,
                          "Slota_CX" = DEG_names_SLota_CX_RAW))

# Inspect the list of classifications
interactions_RAW<-attr(venn_diagram_RAW,"intersections")
interactions_RAW
interactions_RAW<-(t(data.frame(t(sapply(interactions_RAW,c)))))
write.csv(interactions_RAW, file= "venndiagramGenesRelaxed_RAW.csv ")


#Filter data
DEG_data_Verity_Slota_UP <- lapply(DEG_data_Verity_Slota, function(DEG_part) {
  DEG_part<-subset(DEG_part,subset=avg_log2FC > 0.25 & p_val_adj<0.05)
  return(DEG_part)
})

DEG_data_Verity_Slota_DOWN <- lapply(DEG_data_Verity_Slota, function(DEG_part) {
  DEG_part<-subset(DEG_part,subset=avg_log2FC < -0.25 & p_val_adj<0.05)
  return(DEG_part)
})

#Plot Up

#make character vectors of names
DEG_names_SLota_CX_UP<-(DEG_data_Verity_Slota_UP[[1]]$gene)
DEG_names_SLota_HP_UP<-(DEG_data_Verity_Slota_UP[[2]]$gene)
DEG_names_Verity_UP<-(DEG_data_Verity_Slota_UP[[3]]$gene)

library(gplots)
# Create a Venn-diagram given just the list of gene-names for both sets
venn_diagram_UP <- venn(list("Verity_HP" = DEG_names_Verity_UP,
                          "SlotA_HP" = DEG_names_SLota_HP_UP,
                          "Slota_CX" = DEG_names_SLota_CX_UP))

# Inspect the list of classifications
interactions_UP<-attr(venn_diagram_UP,"intersections")
interactions_UP
interactions_UP<-(t(data.frame(t(sapply(interactions_UP,c)))))
write.csv(interactions_UP, file= "venndiagramGenesRelaxed_UP.csv ")

#Plot Down

#make character vectors of names
DEG_names_SLota_CX_DOWN<-(DEG_data_Verity_Slota_DOWN[[1]]$gene)
DEG_names_SLota_HP_DOWN<-(DEG_data_Verity_Slota_DOWN[[2]]$gene)
DEG_names_Verity_DOWN<-(DEG_data_Verity_Slota_DOWN[[3]]$gene)

library(gplots)
# Create a Venn-diagram given just the list of gene-names for both sets
venn_diagram_DOWN <- venn(list("Verity_HP" = DEG_names_Verity_DOWN,
                          "SlotA_HP" = DEG_names_SLota_HP_DOWN,
                          "Slota_CX" = DEG_names_SLota_CX_DOWN))

# Inspect the list of classifications
interactions_DOWN<-attr(venn_diagram_DOWN,"intersections")
interactions_DOWN
interactions_DOWN<-(t(data.frame(t(sapply(interactions_DOWN,c)))))
write.csv(interactions_DOWN, file= "venndiagramGenesRelaxed_DOWN.csv ")

```

```{r}
####MAKE SURE THAT NUMBER OF GENES BEING SELECTED FROM INTERACTIONS OBJECTS ARE THE APPROPRIATE COPMARISON POINTS


##THIS IS A HARDCODED BLOCK

##Trying to reauthor git

#filter Verity by the genes which crossover with Slota to show the crossoverlist

#Verity and both Slota Raw shared DGEs
Verity_Slota_HP_shared_DEGs_RAW <- subset(DEG_data_Verity_Slota[[1]], gene %in% interactions_RAW[[2]]) #interactions 2 is the crossover between Verity_HP.SlotA_HP.Slota_CX
write.csv(Verity_Slota_HP_shared_DEGs_RAW, file= "Shared_DGEs_V_S_RAW.csv ")

#Verity and Slota Hippocampus upregulated DGEs
Verity_Slota_HP_shared_DEGs_UP <- subset(DEG_data_Verity_Slota[[1]], gene %in% interactions_UP[[3]]) #interactions 2 is the crossover between Verity_HP.SlotA_HP.Slota_CX
write.csv(Verity_Slota_HP_shared_DEGs_UP, file= "Shared_DGEs_V_S_UP.csv ")

#Verity HP and Slota CX upregulated DGEs
Verity_HP_Slota_CX_shared_DEGs_UP <- subset(DEG_data_Verity_Slota[[1]], gene %in% interactions_UP[[2]]) #interactions 2 is the crossover between Verity_HP.SlotA_HP.Slota_CX
write.csv(Verity_HP_Slota_CX_shared_DEGs_UP, file= "Shared_DGEs_VHP_SCX_UP.csv ")


#Verity and Slota Hippocampus downregulated DGEs
Verity_Slota_HP_shared_DEGs_DOWN <- subset(DEG_data_Verity_Slota[[1]], gene %in% interactions_DOWN[[2]]) #interactions 2 is the crossover between Verity_HP.SlotA_HP.Slota_CX

write.csv(Verity_Slota_HP_shared_DEGs_DOWN, file= "Shared_DGEs_V_S_DOWN.csv ")
```





## Untested

```{r}
#rename gene id column for Nick's data
DEG_data_Verity_Slota <- lapply(DEG_data_Verity_Slota, function(DEG_part) {
  DEG_part$gene.name<-DEG_part$gene
  DEG_part$gene<-NULL
  return(DEG_part)
})
```


```{r}
mart <- useDataset("mmusculus_gene_ensembl", useMart("ensembl"))
```

```{r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("piano")
library(piano)

#piano_GO terms
GO_terms_m <- getBM(attributes = c("name_1006","ensembl_gene_id"), mart = mart)
GO_terms_m <- GO_terms_m[c('ensembl_gene_id', 'name_1006')]
names(GO_terms_m) <- c('gene.name', "GO_terms")
GO_term_piano <- loadGSC(GO_terms_m)
```


```{r}
#functions
tidy_gsea <- function(x){
  pos <- subset(x, x[3] > 0)
  neg <- subset(x, x[3] < 0)
  
  pos <- pos[c("Name", "Genes (tot)", "Stat (dist.dir)" , "p (dist.dir.up)" , "p adj (dist.dir.up)")]
  neg <- neg[c("Name", "Genes (tot)", "Stat (dist.dir)" , "p (dist.dir.dn)" , "p adj (dist.dir.dn)")]
  
  names(pos) <- c("Name", "gene.NO", 'stat', "pvalue", "padj")
  names(neg) <- c("Name", "gene.NO", 'stat', "pvalue", "padj")
  
  exp_data <- rbind(pos,neg)
  
  return(exp_data)
}

add_gene_dataset <-function(x,dataset){
  x <- x
  term <- x[1]

  gene_names <- subset(GO_terms_m, GO_terms_m$GO_terms == term[[1]])
  if (as.numeric(stat[[1]]) < 0){
    print(paste(as.numeric(stat[[1]]), "in down", sep = " "))
    test <- subset(dataset, dataset$gene.name %in% gene_names[[1]])
    test <- test[order(test$avg_log2FC),]
    gene_name <- paste(test$external_gene_name, collapse = "|")
  }
  else{
    print(paste((stat[[1]]), "in up", sep = " "))
    test <- subset(dataset, dataset$gene.name %in% gene_names[[1]])
    test <- test[order(-test$avg_log2FC),]
    gene_name <- paste(test$external_gene_name, collapse = "|")
  }
 return(gene_name)
}

```

```{r}
#GSEA------------------------------------
#GO FROM HERE, COULD MAKE LOOP FOR EACH GENE LIST IN DEG_data_Verity_Slota
#choose gene list from DEG_data_Verity_Slota
DE_Astrocytes_C3_Psig<-DEG_data_Verity_Slota[[3]] #Verity prion treatment genes
  
#filter based on thresholds
DE_Astrocytes_C3_Psig<-subset(DE_Astrocytes_C3_Psig, subset=p_val_adj<0.05)


#subset the DEG gene lists info to only contain names and logFC
DE_Astrocytes_C3_Psig_piano <- DE_Astrocytes_C3_Psig[,c('gene.name', 'avg_log2FC')]
#change genes column into rownames and only hav logFC
row.names(DE_Astrocytes_C3_Psig_piano) <- DE_Astrocytes_C3_Psig_piano$gene.name
DE_Astrocytes_C3_Psig_piano$gene.name <- NULL

#Run GSE using piano terms
DE_Astrocytes_C3_Psig_piano_gsea <- runGSA(DE_Astrocytes_C3_Psig_piano, gsc=GO_term_piano, geneSetStat="gsea")

#generate summary table
DE_Astrocytes_C3_Psig_piano_gsea_data <- GSAsummaryTable(DE_Astrocytes_C3_Psig_piano_gsea, save=FALSE)

# DE_Astrocytes_C3_Psig_piano_gsea_data <- tidy_gsea(DE_Astrocytes_C3_Psig_piano_gsea_data)

names(DE_Astrocytes_C3_Psig_piano_gsea_data) <- c("Name", "gene.NO", 'stat', "pvalue", "padj")

gene_names_ <- data.frame()
for(i in 1:dim(DE_Astrocytes_C3_Psig_piano_gsea_data)[1]){
  print(paste("start" , i, sep = " "))
  subdata <- DE_Astrocytes_C3_Psig_piano_gsea_data[i,]
  stat <- subdata[3]
  exp <- add_gene_dataset(subdata, DE_Astrocytes_C3_Psig)
  exp <- data.frame(gene_names = exp)
  gene_names_ <- rbind(gene_names_, exp)
}
```

###Generating networks

###Functions needed for networks

```{r}
get_sig_neg <- function(x){
  dat <- subset(x, x$padj <0.1)
  dat <- subset(dat, dat$stat <0)
  return(dat)}
get_sig_pos <- function(x){
  dat <- subset(x, x$padj <0.1)
  dat <- subset(dat, dat$stat >0)
  return(dat)}

#to take the top items take order function and head - around 10-15 values usually on SS plots

make_Col_pos <- function(x){
  data <- data.frame(pval=V(x)$pvalue)
  pal_col <- colorRampPalette(c("yellow","red"))
  exp_table <- pal_col(20)[as.numeric(cut(data$pval,breaks = 20))]
  return(exp_table)
}
make_Col_neg <- function(x){
  data <- data.frame(pval=V(x)$pvalue)
  pal_col <- colorRampPalette(c("white","blue"))
  exp_table <- pal_col(20)[as.numeric(cut(data$pval,breaks = 20))]
  return(exp_table)
}

#this divides the gradient into 20 sections: exp_table <- pal_col(20)[as.numeric(cut(data$pval,breaks = 20))
#the padj are assigned to the 20 divided sections relative to same dataset, not binned by actual padj

get_nodes <- function(x, direc){
  if(!(direc %in% c("pos", "neg"))){stop("set direction as pos or neg with quotation")}
  else if(direc == "pos"){data <- get_sig_pos(x)}
  else if(direc == "neg"){data <- get_sig_neg(x)}

  data$pvalue <- -log10(data$pvalue)
  return(data)
}

#used in determination of circle size

get_edge <- function(x, full,direc){
  if(!(direc %in% c("pos", "neg"))){stop("set direction as pos or neg with quotation")}
  else if(direc == "pos"){data_ <- get_sig_pos(x)}
  else if(direc == "neg"){data_ <- get_sig_neg(x)}

  full_data <- full
  name <- data_$Name

 
  exp <- NULL

  for(n in name){
    first <- subset(full_data, full_data$GO_terms == n)
    for(s in name){
      if(n!=s){
        second <- subset(full_data, full_data$GO_terms == s)
        ovlap <- subset(first, first$gene.name %in% second$gene.name)
        overlap <- dim(ovlap)[1]
        start <- first$GO_terms[1]
        end <- second$GO_terms[1]
       
        data <- data.frame(start = start, end= end, weight = overlap)
       
        exp <- rbind(exp,data)
      }
    }
  }
  exp <- as.data.frame(exp)
  exp <- subset(exp, exp$weight !=0)
  return(exp)
}

#determines clustering - effectively loops through GO terms comparing degree of overlap

#ASK FOR CLARIFICATION ON THIS CODE

networks <- function(data,full,direc){
  nodes <- get_nodes(data, direc)
  edge <- get_edge(data,full,direc)
  net_IP <- graph_from_data_frame(d=edge[!duplicated(apply(edge[1:2],1,function(x) paste(sort(x),collapse=''))),],
                                  vertices=nodes, directed=FALSE)

#igraph network package plot   
  
  V(net_IP)$size <- V(net_IP)$pvalue *2
  V(net_IP)$frame.color <- "white"

  if(direc == "pos"){V(net_IP)$color <- make_Col_pos(net_IP)}
  else if(direc == "neg"){V(net_IP)$color <- make_Col_neg(net_IP)}

  E(net_IP)$arrow.mode <- 0
  E(net_IP)$width <- E(net_IP)$weight/500
  l_IP <- layout_with_fr(net_IP)
  plot(net_IP, layout=l_IP)
}
```

#Generating networks 

```{r}
networks(DE_Astrocytes_C3_Psig_piano_gsea_data, GO_terms_m , 'pos')
DE_Astrocytes_C3_Psig_piano_gsea_data <- cbind(DE_Astrocytes_C3_Psig_piano_gsea_data, gene_names_)

#write.csv(DE_Astrocytes_C3_Psig_piano_gsea_data, "E:/R_231222/DE_Astrocytes_C3_Psig_piano_gsea_data.csv")

```


```{r}
#COMPARISON 2
#list of samples to merge
comp2a<-list(subset(Slo_singlets_merged,subset=sample==c("RML122HP","RML142HP","RML133HP","RML132HP","RML138HP","RML145HP","RML140HP"))) #FIXME check sample names
comp2b<-list(subset(Ver_singlets_merged,subset=sample==c("sample5", "sample6")))
comp2c<-list(subset(Ver_singlets_merged,subset=sample==c("OX1X","OX2X","OX3X", "OX4X","OX5X","OX6X","OX7X","OX8X")))

comp2<-list(comp2a,comp2b, comp2c)
# Merge raw samples, adapted from here https://hbctraining.github.io/scRNA-seq_online/lessons/06a_integration_harmony.html
comp2_merged <-Merge_Seurat_List(list_seurat=comp1) 

rm(list(comp2))
gc()

# Perform log-normalization and feature selection, as well as SCT normalization on global object
comp2_merged <- comp2_merged %>%
    NormalizeData() %>%
    FindVariableFeatures(selection.method = "vst", nfeatures = 2000) %>% 
    ScaleData() %>%
    SCTransform(vars.to.regress = c("mitoRatio")) #FIXME do we need this?

# Calculate PCs using variable features determined by SCTransform (3000 by default)
comp2_merged <- RunPCA(comp2_merged, assay = "SCT", npcs = 50)

comp2_merged_harmonized <- RunHarmony(comp2_merged, 
				group.by.vars = c("sample_id", "experiment_date"), #FIXME variable names to integrate on
				reduction = "pca", assay.use = "SCT", reduction.save = "harmony")

comp2_merged_harmonized <- RunUMAP(comp2_merged_harmonized, reduction = "harmony", assay = "SCT", dims = 1:40)

```
