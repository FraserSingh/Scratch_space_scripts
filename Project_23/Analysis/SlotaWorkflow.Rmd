---
title: "Slota workflow"
output:
  html_document:
    self_contained: false
    code_download: true
date: "2023-05-23"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Seurat for Slota

Adapted from [here](https://bioconductor.org/packages/release/bioc/vignettes/DropletUtils/inst/doc/DropletUtils.html#reading-in-10x-genomics-data) and [here](https://www.singlecellcourse.org/scrna-seq-analysis-with-bioconductor.html).

```{r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

BiocManager::install("DropletUtils", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")
BiocManager::install("Seurat", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

remotes::install_github('chris-mcginnis-ucsf/DoubletFinder', lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

if (!require("SoupX", quietly = TRUE))
    install.packages("SoupX", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

if (!require("scCustomize", quietly = TRUE))
    install.packages("scCustomize", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

BiocManager::install("glmGamPoi", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

if (!require("DESeq2", quietly = TRUE))
    install.packages("DESeq2", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

install.packages("Polychrome")
```

```{r}
library(DropletUtils)
library(Seurat)
library(tidyverse)
library(dplyr)
library(stringr)
library(knitr)
library(DoubletFinder)
library(SoupX)
library(scCustomize)
library(DESeq2)
library(Polychrome)
```

```{r}
folder_path_slota<-c("/localdisk/home/s2268606/University_Directories/Project_23/External_datasets/Slota_paper")

#load Slota paper 

#This is the metadata file, but the information is not very useful and loads in as NAs
# raw_objects_metadata<- read.csv(paste0(folder_path_slota,"/metadata.csv"), header = T)
# #remove the extra row about categories
# raw_objects_metadata<-raw_objects_metadata[2:nrow(raw_objects_metadata),]

#Load counts
rawtable<-Read10X(paste0(folder_path_slota,"/raw_feature_bc_matrix"))

Slota_raw_obj<-CreateSeuratObject(counts=rawtable, project="Slota")
```

## Identify mitochondrial and ribosomal populations

```{r}
#identify mitochondrial and ribosomal protein gene portions, annotations syntax tailored to mouse
Slota_raw_obj[["percent.mt"]]<- PercentageFeatureSet(Slota_raw_obj, pattern = "^Mt")
Slota_raw_obj[["percent.rp"]]<- PercentageFeatureSet(Slota_raw_obj, pattern = "^Rp")

#Generate genes per umi counts, from https://github.com/hbctraining/scRNA-seq/blob/master/lessons/04_SC_quality_control.md
Slota_raw_obj[["log10GenesPerUMI"]] <- log10(Slota_raw_obj$nFeature_RNA) / log10(Slota_raw_obj$nCount_RNA)

Slota_raw_obj[["mitoRatio"]] <- Slota_raw_obj@meta.data$percent.mt / 100
```

## Initial data assessment

```{r}
png("Slota_Preliminary_Data_assessment.png", width=2000)
VlnPlot(Slota_raw_obj, features=c("nFeature_RNA","nCount_RNA","percent.mt", "percent.rp"), ncol=4, pt.size = 0.01)+ ggplot2::ggtitle("Preliminary Data assessment", subtitle= "Slota, unfiltered")
dev.off()
```

Low mitochondrial counts compared to Ximerakis, with less than 25%.

## Plot each of these respectively, showing trends in cell health

```{r}
#show mitochondrial proportion in reads
png("Slota_UMIs per cell vs.mitochondrial genes detected.png", width=1000)
FeatureScatter(Slota_raw_obj, feature1 = "nCount_RNA", feature2 = "percent.mt")+ggplot2::ggtitle("UMIs per cell vs. % mitochondrial genes detected")
dev.off()

png("Slota_UMIs_per_cell_vsribosomal_protein_genes_detected.png", width=1000)
#show ribosomal proportion in reads
FeatureScatter(Slota_raw_obj, feature1 = "nCount_RNA", feature2 = "percent.rp")+ggplot2::ggtitle("UMIs per cell vs. % ribosomal protein  genes detected")
dev.off()

png("Slota_ribosomal_protein_genes_detected_vsmitochondiral_genes_detected.png", width=1000)
#Ribosomal vs mitochondrial 
FeatureScatter(Slota_raw_obj, feature1 = "percent.rp", feature2 = "percent.mt")+ggplot2::ggtitle("% ribosomal protein  genes detected vs. % mitochondiral genes detected")
dev.off()
```

```{r}
#Show overall reads and gene counts for unfiltered data.
png("Slota_UMIs_per_cell_vs_number_of_genes.png", width=1000)
FeatureScatter(Slota_raw_obj, feature1 = "nCount_RNA", feature2="nFeature_RNA",raster=FALSE, pt.size = 0.05)+ ggplot2::geom_smooth(method="lm")+ ggplot2::ggtitle("UMIs per cell vs. number of genes ")
dev.off()
```

The data curve sits a bit high, and there is a biforcation in the middle of the graph.... possible patterns or disparities in the data generated based on brain location or experimental method?

### Add metadata, adding sample identity

adapted from <https://youtu.be/p49seH2_i8Y?t=312>

```{r}

#Check whether the whole block is needed here
sampleLabs<-names(Slota_raw_obj@active.ident)

#Assigning names to the samples to keep identity
#From Chat GPT

sample_detect <- case_when(
  str_detect(sampleLabs, "PBS25HP") ~ "PBS25HP",
  str_detect(sampleLabs, "PBS48CX") ~ "PBS48CX",
  str_detect(sampleLabs, "PBS48HP") ~ "PBS48HP",
  str_detect(sampleLabs, "PBS60CX") ~ "PBS60CX",
  str_detect(sampleLabs, "PBS61CX") ~ "PBS61CX",
  str_detect(sampleLabs, "PBS73CX") ~ "PBS73CX",
  str_detect(sampleLabs, "RML122CX") ~ "RML122CX",
  str_detect(sampleLabs, "RML122HP") ~ "RML122HP",
  str_detect(sampleLabs, "RML132CX") ~ "RML132CX",
  str_detect(sampleLabs, "RML132HP") ~ "RML132HP",
  str_detect(sampleLabs, "RML133CX") ~ "RML133CX",
  str_detect(sampleLabs, "RML133HP") ~ "RML133HP",
  str_detect(sampleLabs, "RML134CX") ~ "RML134CX",
  str_detect(sampleLabs, "RML138CX") ~ "RML138CX",
  str_detect(sampleLabs, "RML138HP") ~ "RML138HP",
  str_detect(sampleLabs, "RML140CX") ~ "RML140CX",
  str_detect(sampleLabs, "RML140HP") ~ "RML140HP",
  str_detect(sampleLabs, "RML142CX") ~ "RML142CX",
  str_detect(sampleLabs, "RML142HP") ~ "RML142HP",
  str_detect(sampleLabs, "RML145CX") ~ "RML145CX",
  str_detect(sampleLabs, "RML145HP") ~ "RML145HP",
  TRUE ~ NA_character_
)

#set the labels we generated
Slota_raw_obj@meta.data$sample<-sample_detect
Idents(object=Slota_raw_obj)<-"sample"
rm(sampleLabs, sample_detect)
```

### Save the whole data

```{r}
#Save the data object
#save(Slota_raw_obj, file="./Rdata/Slota_raw_seurat.RData")
```

### Create metadata variable to edit it without affecting core data

```{r}
# Rename columns from https://github.com/hbctraining/scRNA-seq/blob/master/lessons/04_SC_quality_control.md

#Create metadata variable to edit it without affecting core data
metadata_test<-Slota_raw_obj@meta.data

#Saving cell barcodes as metainfo
metadata_test$cells<-rownames(metadata_test)

metadata_test <- metadata_test %>%
    dplyr::rename(nUMI = nCount_RNA,
                  nGene = nFeature_RNA)


```

### Counts per sample

This shows over 300k cells for some samples, indicating that minimum metrics must be set to remove junk.

```{r}
# Visualize the number of cell counts per sample with no filtering at all
png("Slota_Cell_counts_per_sample1.png", width=1500)
metadata_test %>% 
  	ggplot2::ggplot(aes(x=sample, fill=sample)) + 
  	geom_bar() +
  	theme_classic() +
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  	theme(plot.title = element_text(hjust=0.5, face="bold")) +
  	ggplot2::ggtitle("Cell counts per sample", subtitle="Slota, unfiltered")
dev.off()
```

### UMI/ transcripts per cell

With line at 500 for ideal minimum

```{r}
# Visualize the number UMIs/transcripts per cell
png("Slota_UMI_transcripts_per_cell.png", width=1000)
metadata_test %>% 
  	ggplot(aes(color=sample, x=nUMI, fill= sample)) + 
  	geom_density(alpha = 0.2) + 
  	scale_x_log10() + 
  	theme_classic() +
  	ylab("Cell density") +
  	geom_vline(xintercept = 500)+
    ggplot2::ggtitle("UMI/transcripts per cell", subtitle="Slota, filtered to minimum 20 genes")
dev.off()
```

### Genes per cell

```{r}
# Visualize the distribution of genes detected per cell via histogram
png("Slota_Distribution_of_genes_per_cell1.png", width=1000)
metadata_test %>% 
  	ggplot(aes(color=sample, x=nGene, fill= sample)) + 
  	geom_density(alpha = 0.2) + 
  	theme_classic() +
  	scale_x_log10() + 
  	geom_vline(xintercept = 300)+
    ggplot2::ggtitle("Distribution of genes per cell", subtitle="Slota, filtered to minimum 20 genes")
dev.off()

# Visualize the distribution of genes detected per cell via boxplot
png("Slota_Distribution_of_genes_per_cell2.png", width=1000)
metadata_test %>% 
  	ggplot(aes(x=sample, y=log10(nGene), fill=sample)) + 
  	geom_boxplot() + 
  	theme_classic() +
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  	theme(plot.title = element_text(hjust=0.5, face="bold")) +
  	ggplot2::ggtitle("Distribution of genes per cell", subtitle="Slota, filtered to minimum 20 genes")
dev.off()
```

### UMI vs. genes detected

We want cells in top right

```{r}
#Some code commented out because it introduced infitine values with a log transform
# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs
png("Slota_UMIs_vs_genes_detected.png", width=2000)
metadata_test %>% 
  	ggplot(aes(x=nUMI, y=nGene, color=mitoRatio)) + 
  	geom_point() + 
	scale_colour_gradient(low = "gray90", high = "black") +
  	#stat_smooth(method=lm) +
  	scale_x_log10() +
  	scale_y_log10() +
  	theme_classic() +
  	geom_vline(xintercept = 500) +
  	geom_hline(yintercept = 250) +
  	facet_wrap(~sample) +
    ggplot2::ggtitle("UMIs vs. genes detected", subtitle = "Slota, minimum 20 genes")
dev.off()
```

### MitoRatio

We want data lower than 0.2

```{r}
# Visualize the distribution of mitochondrial gene expression detected per cell
png("Slota_Distribution_of_mitochondrial_gene_expression_per_cell.png", width=1000)
metadata_test %>% 
  	ggplot(aes(color=sample, x=mitoRatio, fill=sample)) + 
  	geom_density(alpha = 0.2) + 
  	scale_x_log10() + 
  	theme_classic() +
  	geom_vline(xintercept = 0.2)+
    ggplot2::ggtitle("Distribution of mitochondrial gene expression per cell", subtitle="Slota, filtered to minimum 20 genes")
dev.off()
```

```{r}
png("Slota_Repeat_mitoratio.png", width=1000)
FeatureScatter((subset(Slota_raw_obj, subset= nFeature_RNA > 20)), feature1 = "nFeature_RNA", feature2 = "percent.mt")
dev.off()
```

### Complexity

Should be above 0.8.

```{r}
# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI
png("Slota_Complexity_of_gene_expression_genes_per_UMI2.png", width=1000)
metadata_test %>%
  	ggplot(aes(x=log10GenesPerUMI, color = sample, fill=sample)) +
  	geom_density(alpha = 0.2) +
  	theme_classic() +
  	geom_vline(xintercept = 0.8)+
    ggplot2::ggtitle("Complexity of gene expression (genes per UMI)", subtitle="Slota, filtered to minimum 20 genes")
dev.off()
```

Unsure if any filters are really needed, except perhaps an uper limit on nUMI? uncomment in source view if desired

<!-- ### Assign filters to data -->

<!-- ```{r} -->

<!-- #filter out the cells with mitochondrial genes more than 20% and genes with more than .... genes as instructed by Nick -->

<!-- temp_meta<-Slota_raw_obj@meta.data -->

<!-- temp_meta <- temp_meta %>% -->

<!--     dplyr::rename(nUMI = nCount_RNA, -->

<!--                   nGene = nFeature_RNA) -->

<!-- Slota_raw_obj@meta.data<-temp_meta -->

<!-- Slota_filtered<- subset(Slota_raw_obj,subset=  -->

<!--                               percent.mt <20 & -->

<!--                               nUMI > 0 & -->

<!--                               nGene >150 -->

<!--                             ) -->

<!-- rm(temp_meta, metadata_test) -->

<!-- ``` -->

### Gene-level filtering

Keeping genes which appear in more than 3 cells for statistical power.

```{r}

# Output a logical vector for every gene on whether the more than zero counts per cell

# Extract counts

counts <- GetAssayData(object = Slota_filtered, slot = "counts")

# Output a logical vector for every gene on whether the more than zero counts per cell

nonzero <- counts > 0

# Sums all TRUE values and returns TRUE if more than 3 TRUE values per gene

keep_genes <- Matrix::rowSums(nonzero) >= 3

# Only keeping those genes expressed in more than 10 cells

filtered_counts <- counts[keep_genes, ]

# Reassign to filtered Seurat object

Slota_filtered <- CreateSeuratObject(filtered_counts, meta.data = Slota_filtered@meta.data)

rm(filtered_counts, nonzero,counts, keep_genes)

```

### Saving object

```{r}
# Create .RData object to load at any time
save(Slota_raw_obj, file="./Rdata/Slota_filtered.RData")
```



## Doublet finder for all samples

```{r}

#load in the filtered Slota object
#load("./Rdata/Slota_filtered.RData")

#adapted from https://youtu.be/p49seH2_i8Y , https://github.com/kpatel427/YouTubeTutorials/blob/5b3c795cecafb22f0e992da069eae2efd6b5cb95/singleCell_doublets.R , https://rpubs.com/kenneditodd/doublet_finder_example 

Slota.list <- SplitObject(Slota_raw_obj, split.by = "sample")

# Perform doublet detection on each sample using lapply
Slota.list <- lapply(Slota.list, function(sample) {
  print(paste0("Sample ",sample@meta.data$sample[1]))
  # Pre-process seurat object with standard seurat workflow
  sample <- SCTransform(sample)
  sample <- RunPCA(sample)
  
  # Find significant PCs
  stdv <- sample[["pca"]]@stdev
  sum.stdv <- sum(sample[["pca"]]@stdev)
  percent.stdv <- (stdv / sum.stdv) * 100
  cumulative <- cumsum(percent.stdv)
  co1 <- which(cumulative > 90 & percent.stdv < 5)[1]
  co2 <- sort(which((percent.stdv[1:length(percent.stdv) - 1] -
                       percent.stdv[2:length(percent.stdv)]) > 0.1),
              decreasing = TRUE)[1] + 1
  min.pc <- min(co1, co2)
  
  # Finish pre-processing
  sample <- RunUMAP(sample, dims = 1:min.pc)
  sample <- FindNeighbors(object = sample, dims = 1:min.pc)              
  sample <- FindClusters(object = sample, resolution = 0.1)
  
  # pK identification (no ground-truth)
  sweep.list <- paramSweep_v3(sample, PCs = 1:min.pc, sct = TRUE)
  sweep.stats <- summarizeSweep(sweep.list)
  bcmvn <- find.pK(sweep.stats)
  
  # Optimal pK is the max of the bomodality coefficient (BCmvn) distribution
  bcmvn.max <- bcmvn[which.max(bcmvn$BCmetric),]
  optimal.pk <- as.numeric(bcmvn.max$pK)

  # Homotypic doublet proportion estimate
  annotations <- sample@meta.data$seurat_clusters
  homotypic.prop <- modelHomotypic(annotations) 
  nExp.poi <- round(0.087 * nrow(sample@meta.data))
  nExp.poi.adj <- round(nExp.poi * (1 - homotypic.prop))
  
  # Run DoubletFinder
  sample <- doubletFinder_v3(seu = sample, 
                             PCs = 1:min.pc, 
                             pK = optimal.pk,
                             nExp = nExp.poi.adj, 
                             sct = TRUE, 
                             pN=0.25)
  
  return(sample)
  
})

#Rename the columns
Slota.list <- lapply(Slota.list, function(sample) {
  doublet_col_index <- which(grepl("DF.classifications_", colnames(sample@meta.data)))
  sample$doublet_finder <- sample@meta.data[doublet_col_index]
  sample@meta.data[doublet_col_index]<-NULL
  return(sample)
})

#subset data by singlet status
Slota.list.singlets <- lapply(Slota.list, function(sample) {
  sample<- subset(sample, subset= doublet_finder == 'Singlet')
  return(sample)
  })
```

```{r}
#merge the data back together
Slota_singlets_merged <- Merge_Seurat_List(list_seurat = Slota.list.singlets)
rm(Slota.list.singlets)
```

### Saving object

```{r}
# Create .RData object to load at any time
save(Slota_singlets_merged, file="Rdata/Slo_singlets_merged.RData")
```

## Clustering

```{r}

#load("Rdata/Slota_singlets_merged.RData")

Slota_singlets_merged@active.assay<-"RNA"

Slota_singlets_merged <- NormalizeData(Slota_singlets_merged, verbose = T)
Slota_singlets_merged <- FindVariableFeatures(Slota_singlets_merged, verbose = T)
Slota_singlets_merged <- ScaleData(Slota_singlets_merged, verbose = T)


# run sctransform instead
# Slota_singlets_merged <- SCTransform(Slota_singlets_merged, vars.to.regress = "percent.mt", verbose = TRUE, conserve.memory = TRUE)
# 


gc()

Slota_singlets_merged <- RunPCA(Slota_singlets_merged, verbose = TRUE)
ElbowPlot(Slota_singlets_merged, ndims=30)
```

Elbow plot shows a final drop in Sd around 23, so will use 25 PCs

```{r}
Slota_singlets_merged <- RunUMAP(Slota_singlets_merged, dims = 1:25, verbose = TRUE)

Slota_singlets_merged <- FindNeighbors(Slota_singlets_merged, dims = 1:25, verbose = TRUE)
Slota_singlets_merged <- FindClusters(Slota_singlets_merged, verbose = TRUE, resolution = 1, random.seed = 42)

DimPlot(Slota_singlets_merged, label = TRUE, raster=FALSE) + NoLegend()+ ggtitle("Slota clustering", subtitle = "NormalizeData, clustering resolution= 1, UMAPdims25")


DimPlot(Slota_singlets_merged, raster=FALSE, group.by = "sample", repel = TRUE)+ ggtitle("Slota clustering", subtitle = "NormalizeData, clustering resolution= 1, UMAPdims25")

save(Slota_singlets_merged, file="Rdata/Slota_clustering.RData")
```

```{r}
#Add metadata on treatment, adapted from Chat GPT
Slo_singlets_merged<-Slota_singlets_merged
rm(Slota_singlets_merged)
gc()

#Slota
sampleLabs_Slota<- names(Slo_singlets_merged@active.ident)

treat_detect_Slota <- case_when(
  str_detect(sampleLabs_Slota, "RML.*HP*") ~ "RML_HP",
  str_detect(sampleLabs_Slota, "PBS.*HP*") ~ "PBS_HP",
  str_detect(sampleLabs_Slota, "RML.*CX*") ~ "RML_CX",
  str_detect(sampleLabs_Slota, "PBS.*CX*") ~ "PBS_CX",
  TRUE ~ NA_character_
)

Slo_singlets_merged@meta.data$treatment<-treat_detect_Slota
Idents(object=Slo_singlets_merged)<-"treatment"
rm(treat_detect_Slota, sampleLabs_Slota)

```


## Pre-treat the data for clustering

```{r}
# adapted from https://satijalab.org/seurat/articles/integration_introduction.html

#FIXME set the RNA assay as active
DefaultAssay(Slo_singlets_merged) <- "RNA"

# split the dataset into a list of three seurat objects (ME7, NBH, AGEING)
Slo_list<-SplitObject(Slo_singlets_merged, split.by = "treatment")
rm(Slo_singlets_merged)
gc()


# normalize and identify variable features for each dataset independently
Slo_list <- lapply(X = Slo_list, FUN = function(x) {
    x <- NormalizeData(x)
    x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
})

# select features that are repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = Slo_list,verbose = TRUE)
```

### RPCA options

from [<https://satijalab.org/seurat/articles/integration_rpca.html>]

```{r}
gc()
#Perform PCA on the data individually before integration
Slo_list <- lapply(X = Slo_list, FUN = function(x) {
    x <- ScaleData(x, features = features, verbose = TRUE)
    x <- RunPCA(x, features = features, verbose = TRUE)
})

#Use RPCA
Slota.anchors <- FindIntegrationAnchors(object.list = Slo_list, anchor.features = features, verbose=TRUE, reduction='rpca')

# this command creates an 'integrated' data assay
Slota.combined <- IntegrateData(anchorset = Slota.anchors, verbose=TRUE)
```

```{r}
# specify that we will perform downstream analysis on the corrected data note that the
# original unmodified data still resides in the 'RNA' assay
DefaultAssay(Slota.combined) <- "integrated"

# Run the standard workflow for visualization and clustering
Slota.combined <- ScaleData(Slota.combined, verbose = FALSE)
Slota.combined <- RunPCA(Slota.combined, npcs = 30, verbose = FALSE)
ElbowPlot(Slota.combined, ndims=30)+ggtitle("Elbowplot of Integrated Slota data", subtitle = "RunPCA npcs=30, RPCA workflow")
```

Elbow plot shows around 25 Pcs again 

```{r}
#20 PCs seem to cover the variability
Slota.combined <- RunUMAP(Slota.combined, reduction = "pca", dims = 1:25)
Slota.combined <- FindNeighbors(Slota.combined, reduction = "pca", dims = 1:25)
Slota.combined <- FindClusters(Slota.combined, resolution = c(0.2,0.3,0.5,0.7,1))

#cyclechange resolution number in group.by to see difference in clusters
DimPlot(Slota.combined, reduction = 'umap', label = TRUE, repel = TRUE, raster=F)+ggtitle("Integrated Slota data, labelled by cluster numbers", subtitle="RPCA,Clustering resolution 1, 25 PCs used")

DimPlot(Slota.combined, group.by="integrated_snn_res.0.2", label = TRUE, repel = TRUE, raster=F)

#set the idents to 0.2
Slota.combined@active.ident<-Slota.combined@meta.data$integrated_snn_res.0.2
levels(Slota.combined)

#Save the object
save(Slota.combined,file="Rdata/Slota.self_integrated_RPCA.Rdata")
```

```{r}
# Visualization
p1 <- DimPlot(Slota.combined, reduction = "umap", split.by = "treatment", raster=FALSE)+ ggtitle("Integrated Slota data, split by treatment", subtitle="RPCA,Clustering resolution 0.2, 25 PCs used")

#Check for sample batch effects (shouldn't see this in an integrated dataset). The colou pallete hides sample11 because it covers everything

#show that sample RML133HP 
p2 <- DimPlot(Slota.combined, reduction = 'umap', raster=F, split.by = 'treatment')+ggtitle("Terminal dataset, split by treatment and labelled by sample")

#This plot would be to label by cell type, not useable as I haven't used singleR yet
# p3 <- DimPlot(Slota.combined, reduction = "umap", group.by = "seurat_annotations", label = TRUE,repel = TRUE, raster=FALSE)


#show the plots
p1 + p2 #+p3
```

##Preliminary Astrocyte checks

```{r}
DefaultAssay(Slota.combined)<-"RNA"

#Check for a gene of interest in the data's geneset
Gene_Names<-Slota.combined@assays[["RNA"]]@counts@Dimnames[[1]]
filtered_gene_names<-Gene_Names[!grepl("^\\d", Gene_Names)]
filtered_gene_names[grep("^Aldh1lh", filtered_gene_names)]

#try to identify astrocytes  with genes (Aldh1l1, Syp, Csf1r,Tmem119, Map2, Gfap)

astrocyte_genes<-c("Aldh1l1","Gfap","Slc1a2")

FeaturePlot(Slota.combined,features=astrocyte_genes, raster=F)+ggtitle("Integrated Verity data, labelled with astrocyte gene markers", subtitle="RPCA,Clustering resolution 0.2, 25 PCs used")
#+scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) + ggtitle("ALDH1 for astrocytes")
```


## Cell annotation

```{r}

library(SingleR)
library(celldex)

#FIXME change the reference which is loaded to the mouse one
#library(celldex)
mouse.ref <- celldex::MouseRNAseqData()

sce <- as.SingleCellExperiment(Slota.combined)

mouse.main <- SingleR(test=sce, ref=mouse.ref, labels=mouse.ref$label.main, de.method="wilcox")

mouse.fine <- SingleR(test=sce, ref=mouse.ref, labels=mouse.ref$label.fine, de.method="wilcox")

table(mouse.fine$labels)

# https://github.com/LTLA/SingleR/blob/master/README.md
#Add annotation back to Seruat object
Slota.combined[["SingleR.labels.main"]] <- mouse.main$labels
Slota.combined[["SingleR.labels.fine"]] <- mouse.fine$labels

Slota.combined <- SetIdent(Slota.combined, value = "SingleR.labels.fine")
rm(sce, mouse.fine, mouse.main, mouse.ref)

#Visualise distribution on UMAP
DimPlot(Slota.combined, label = T , repel = T, label.size = 3, raster=F)+ggtitle("Slota dataset integrated clustering", subtitle="Cell annotation with SingleR")
```


## Investigate astrocytes

```{r}

# Convert cluster names to character
Idents(Slota.combined) <- as.character(Idents(Slota.combined))
VlnPlot(Slota.combined, features = "Slc1a2")

#Subset out astrocytes
Slo_astrocytes<-subset(Slota.combined, idents=c('Astrocytes', 'Astrocytes activated'))

#Show the data membership acorss cell type in the astrocyte set
table(Slo_astrocytes$treatment)
table(Slo_astrocytes$SingleR.labels.fine)

#find clustered astrocyte markers, differences in astrocyte populations

DefaultAssay(Slo_astrocytes)<-'RNA'

#make counts whole numbers
Slo_astrocytes@assays$RNA@counts@x <-round(Slo_astrocytes@assays$RNA@counts@x)

#'solution' from github forums is to add counts to all genes to remove 0 mean https://github.com/satijalab/seurat/issues/1570
Slo_astrocytes[["RNA"]]@counts<-as.matrix(Slo_astrocytes[["RNA"]]@counts)+1

astrocyte.markers <- FindMarkers(Slo_astrocytes, 
                                 ident.1 = 'Astrocytes', 
                                 min.pct = 0.25,
                                 verbose = TRUE,
                                 slot='counts',
                                 test.use = 'DESeq2'
                                 )
head(astrocyte.markers, n = 6)
save(astrocyte.markers, file="Slota_astrocyte.markers.RData")
```


## Find DEGs within the astrocyte subclusters


```{r}
#subset, then cluster? Or add Slota first then do this analysis?
DefaultAssay(Slo_astrocytes)<-"integrated"

# Run the standard workflow for visualization and clustering
Slo_astrocytes <- ScaleData(Slo_astrocytes, verbose = FALSE)
Slo_astrocytes <- RunPCA(Slo_astrocytes, npcs = 30, verbose = FALSE)
ElbowPlot(Slo_astrocytes, ndims=30)+ggtitle("Elbowplot of Integrated Slota data", subtitle = "RunPCA npcs=30, RPCA workflow")

#30 PCs seem to cover the variability
Slo_astrocytes <- RunUMAP(Slo_astrocytes, reduction = "pca", dims = 1:30)
Slo_astrocytes <- FindNeighbors(Slo_astrocytes, reduction = "pca", dims = 1:30)
Slo_astrocytes <- FindClusters(Slo_astrocytes, resolution = c(0.2,0.3,0.5,0.7,1))


DimPlot(Slo_astrocytes, group.by="integrated_snn_res.0.3", label = TRUE, repel = TRUE, raster=F)

#cyclechange resolution number in group.by to see difference in clusters
DimPlot(Slo_astrocytes, reduction = 'umap', label = TRUE, repel = TRUE, raster=F)+ggtitle("Integrated Slota data's astrocytes, labelled by treatment", subtitle="13 clusters")

#set the idents to 0.3
Slo_astrocytes@active.ident<-Slo_astrocytes@meta.data$integrated_snn_res.0.3
levels(Slo_astrocytes)

#show that there are not many activated astrocytes annotated by SingleR
Slo_astrocytes <- SetIdent(Slo_astrocytes, value = "SingleR.labels.fine")
DimPlot(Slo_astrocytes, label = TRUE, repel = TRUE, raster=F)+ggtitle("Slota astrocytes",subtitle="Annotated by SingleR")
```

### Check for astrocyte subpopulations accoridng to literature 

Need to build profiles of astrocytes according to the publish literature. 

Can then find markers for the subclusters of interest

```{r}
#Carry on with analysis
Slo_astrocytes <- SetIdent(Slo_astrocytes, value = "integrated_snn_res.0.3")
DefaultAssay(Slo_astrocytes)<-'RNA'

#set identities to subclusters
Idents(Slo_astrocytes) <- as.character(Idents(Slo_astrocytes))

astrocyte_subcluster.markers <- FindMarkers(Slo_astrocytes, ident.1 = 0, min.pct = 0.25, verbose = TRUE, test.use = "DESeq2")

#by treatment, show the genes DE in Prion condition. LogFC set to a *1 increase in fold change
#Compare the RML HP to the PBS HP samples
Slo_astrocytes@active.ident<-as.factor(Slo_astrocytes$treatment)

#check grouping of data by treatment
DimPlot(Slo_astrocytes, label = TRUE, repel = TRUE, raster=F, group.by="treatment")+ggtitle("Slota astrocytes",subtitle="Annotated by treatment")

Slota_astrocyte_prion.markers <- FindMarkers(Slo_astrocytes, ident.1 = 'RML_HP',ident.2 = 'PBS_HP', min.pct = 0.15, verbose = TRUE, test.use = "DESeq2", logfc.threshold = 0.50)

#Sort the list in descending log2FC and ascending pvalues
Slota_astrocyte_prion.markers<-Slota_astrocyte_prion.markers[order(-Slota_astrocyte_prion.markers$avg_log2FC, Slota_astrocyte_prion.markers$p_val), ]
#Save the file
write.csv(Slota_astrocyte_prion.markers, file = "Slota_astrocyte_prion.markers.csv")

save(Slota_astrocyte_prion.markers, file="Slota_astrocyte_prion.markers.RData")

# Do the same for the infected Cortex samples and their control
Slota_astrocyte_prion.markers_CX <- FindMarkers(Slo_astrocytes, ident.1 = 'RML_CX',ident.2 = 'PBS_CX', min.pct = 0.15, verbose = TRUE, test.use = "DESeq2", logfc.threshold = 0.50)

#Sort the list in descending log2FC and ascending pvalues
Slota_astrocyte_prion.markers_CX<-Slota_astrocyte_prion.markers_CX[order(-Slota_astrocyte_prion.markers_CX$avg_log2FC, Slota_astrocyte_prion.markers_CX$p_val), ]
#Save the file
write.csv(Slota_astrocyte_prion.markers_CX, file = "Slota_astrocyte_prion.markers_CX.csv")

save(Slota_astrocyte_prion.markers_CX, file="Slota_astrocyte_prion.markers_CX.RData")

```
