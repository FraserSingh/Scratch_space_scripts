```{r}
if (!require("SoupX", quietly = TRUE))
    install.packages("SoupX")

library(Seurat)
library(tidyverse)
library(SoupX)
library(DropletUtils)
library(ggplot2)
remotes::install_github('chris-mcginnis-ucsf/DoubletFinder')

library(DoubletFinder)
library(knitr)
```

```{r}
#loop to get seurat objects of each filtered and unfiltered file

# List of folder names
sample_names<- readLines("/home/s2268606/University_Directories/Project_23/External_datasets/Ximerakis/Ximerakis_BAM_names.txt")

#rename them for cell ranger counts folders
folder_names <- paste0("cr", sample_names)

# Loop through each folder ###DIFFERENT HERE WITH SHORTER PATH
for (folder_name in folder_names) {
  Raw_folder_path=paste0("/home/s2268606/University_Directories/Project_23/External_datasets/Ximerakis/",folder_name, "/outs/raw_feature_bc_matrix/")
  
  Filtered_folder_path=paste0("/home/s2268606/University_Directories/Project_23/External_datasets/Ximerakis/",folder_name, "/outs/filtered_feature_bc_matrix/")

  
  current_raw_data<-Read10X(data.dir =Raw_folder_path)
  current_filtered_data<-Read10X(data.dir=Filtered_folder_path)
  
  #error trap for one of the variables... not sure which
  if (is.null(colnames(current_raw_data))) {
    cat("Error: No cell names present in the input matrix for folder", folder_name, "\n")
    next  # Skip to the next iteration of the loop
  }
    #error trap for one of the variables... not sure which
  if (is.null(colnames(current_filtered_data))) {
    cat("Error: No cell names present in the input matrix for folder", folder_name, "\n")
    next  # Skip to the next iteration of the loop
  }
  
  #Make soupchannel objects
  current_soup.channel<- SoupChannel(current_raw_data,current_filtered_data)
  
  assign(paste0(folder_name, "_soup"), current_soup.channel)
  
  
  # Assign the object to a variable with the folder name as the variable name
  raw_name<-paste0(folder_name,"_raw")
  filtered_name<-paste0(folder_name,"_filtered")
  
  assign(raw_name, current_raw_data)
  assign(filtered_name,current_filtered_data)  
  
  ## Make raw seurat
  # current_raw_Sobj <- CreateSeuratObject(counts = current_raw_data, project = "Ximerakis")
  # assign(raw_name, current_raw_Sobj)
  
  
  # Make filtered seurat
  current_filtered_Sobj <- CreateSeuratObject(counts = current_filtered_data, project = "Ximerakis")
  
  
    
  assign(filtered_name, current_filtered_Sobj)
}

```

```{r}
#merge the samples into one object
srat <- merge(crOX1X_filtered, y= c(crOX2X_filtered  ,crOX3X_filtered  ,crOX4X_filtered  ,crOX5X_filtered  ,crOX6X_filtered  ,crOX7X_filtered  ,crOX8X_filtered  ,crYX1L_filtered  ,crYX2L_filtered  ,crYX3R_filtered  ,crYX4R_filtered  ,crYX5R_filtered  ,crYX6L_filtered  ,crYX7R_filtered  ,crYX8L_filtered), add.cell.ids=c("OX1X", "OX2X", "OX3X", "OX4X", "OX5X", "OX6X", "OX7X", "OX8X", "YX1L", "YX2L","YX3R", "YX4R", "YX5R" ,"YX6L", "YX7R", "YX8L"), project="Ximerakis")


#cleaning up memory
rm(current_filtered_data, current_filtered_Sobj, current_raw_data, current_soup.channel)
```

```{r}
#Cluster with Seurat
srat    <- SCTransform(srat, verbose = F)
srat    <- RunPCA(srat, verbose = F)
srat    <- RunUMAP(srat, dims = 1:30, verbose = F)
srat    <- FindNeighbors(srat, dims = 1:30, verbose = F)
srat    <- FindClusters(srat, verbose = T)
```

```{r}
#Add clustering from merged object to the original filtered objects of each sample

meta    <- srat@meta.data
umap<- srat@reductions$umap@cell.embeddings

for (sample in sample_names){
  
  #get the metadata subset for just this sample
  #make the metadata recognisable by removing the sample name
  meta_subset <- meta[grep(sample, rownames(meta)), ]
  rownames(meta_subset)<-sub(paste0("^", sample_name, "_"), "", rownames(meta_subset))
  
  umap_subset<-umap[grep(sample, rownames(meta)),]
  rownames(umap_subset)<-sub(paste0("^", sample_name, "_"), "", rownames(umap_subset))

  
  #add it to the corresponding soupX object
  soupname<-ls(pattern = paste0("cr",sample,"_soup"))
    
  soupname  <- setClusters(soupname, setNames(meta_subset$seurat_clusters, rownames(meta_subset)))
  soupname  <- setDR(soupname, umap_subset)
  
}

```

```{r}
#Hopefully add the clustering annotation to soup objects
```

```{r}
#Amended from ChatGPT
meta <- srat@meta.data
umap <- srat@reductions$umap@cell.embeddings

for (sample in soup_group) {
  # Identify the soup object's sample name
  sample_name <- sub("^cr(.*)_.*", "\\1", sample)

  # Construct the row name pattern to match
  rowname_pattern <- paste0("^", sample_name, "_")

  # Find matching row names in the metadata
  matching_rownames <- grep(rowname_pattern, rownames(meta), value = TRUE)

  # Check if any matching row names are found
  if (length(matching_rownames) > 0) {
    # Extract the cluster information for the matching row names
    clusters <- data.frame(meta[matching_rownames, 'seurat_clusters', drop = FALSE])
    rownames(clusters) <- sub(paste0("^", sample_name, "_"), "", rownames(clusters))

    # Assign cluster information and set DR (umap)
    sample <- setClusters(sample, clusters$seurat_clusters)
    sample <- setDR(sample, umap)

    # Update soupchannel object in the collection
    soup_group[sample] <- sample
  }
}


head(meta)
```

```{r}
#Run automatic ambient RNA profiling, might do manual.....
soup.channel  <- autoEstCont(soup.channel)
```

```{r}
#Genes with highest expression in background. These are often enriched for ribosomal proteins.

head(soup.channel$soupProfile[order(soup.channel$soupProfile$est, decreasing = T), ], n = 20)
```

```{r}
adj.matrix  <- adjustCounts(soup.channel, roundToInt = T)
```

```{r}
DropletUtils:::write10xCounts("soupX_pbmc10k_filt", adj.matrix)
```
