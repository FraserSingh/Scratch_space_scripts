---
title: "Verity workflow"
output: html_document
date: "2023-05-23"
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Verity dataset

Adapted from
[here](https://bioconductor.org/packages/release/bioc/vignettes/DropletUtils/inst/doc/DropletUtils.html#reading-in-10x-genomics-data)
and
[here](https://www.singlecellcourse.org/scrna-seq-analysis-with-bioconductor.html).

```{r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

BiocManager::install("DropletUtils", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")
BiocManager::install("Seurat", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

remotes::install_github('chris-mcginnis-ucsf/DoubletFinder', lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

if (!require("SoupX", quietly = TRUE))
    install.packages("SoupX", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

if (!require("scCustomize", quietly = TRUE))
    install.packages("scCustomize", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

BiocManager::install("glmGamPoi", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

if (!require("DESeq2", quietly = TRUE))
    install.packages("DESeq2", lib="/exports/cmvm/eddie/eb/groups/mabbott_grp/Fraser/Project_23/Rpackages")

```

```{r}
library(DropletUtils)
library(Seurat)
library(tidyverse)
library(dplyr)
library(stringr)
library(knitr)
library(DoubletFinder)
library(SoupX)
library(scCustomize)
library(DESeq2)
```

```{r}
#load Verity paper FIXME this will need to be from group folder eventually, so amend paths at the start

#Comment out the samples which aren't needed for the comparison of interest

# List of folder names
folder_names <- c(
  "sample1", "sample2",
  "sample5", "sample6",
  "sample9","sample11"
  )

# Loop through each folder
for (folder_name in folder_names) {
  folder_path=paste0("/home/s2268606/University_Directories/Project_23/Group_data/",folder_name, "/DGE_unfiltered")
  
  #Load the matrix file
  current_parse <- ReadParseBio(folder_path)
  
  #see if there are any empty gene names
  table(rownames(current_parse) == "") 
  
  #Load the metadata
  current_metadata<-read.csv(paste0(folder_path,"/cell_metadata.csv"))

  #Create a seurat object
  current_parse_interpreted <- CreateSeuratObject(current_parse, meta.data = current_metadata, names.delim = "")
  
  #set identities to the sample, may be overwritten later
  current_parse_interpreted@meta.data$orig.ident <- factor(rep(folder_name, nrow(current_parse_interpreted@meta.data)))
  
  Idents(current_parse_interpreted) <- current_parse_interpreted@meta.data$orig.ident


  # Assign the object to a variable with the folder name as the variable name
  assign((paste0(folder_name, "_obj")),current_parse_interpreted)

}


#merge the samples into one object
Verity_total <- merge(sample1_obj, y=c(sample2_obj, sample5_obj, sample6_obj, sample9_obj,sample11_obj), add.cell.ids=c("sample1", "sample2", "sample5", "sample6", "sample9", "sample11"), project="Verity")

#cleaning up memory
rm("sample1_obj","sample2_obj", "sample5_obj", "sample6_obj", "sample9_obj", "sample11_obj", current_metadata, current_parse_interpreted, current_parse)
```

## Identify mitochondrial and ribosomal populations

```{r}
#ID mitochondrial dominant cells 
Verity_total[["percent.mt"]]<- PercentageFeatureSet(Verity_total, pattern = "^mt")
Verity_total[["percent.rp"]]<- PercentageFeatureSet(Verity_total, pattern = "^Rp")

#Generate genes per umi counts, from https://github.com/hbctraining/scRNA-seq/blob/master/lessons/04_SC_quality_control.md
Verity_total$log10GenesPerUMI <- log10(Verity_total$nFeature_RNA) / log10(Verity_total$nCount_RNA)

Verity_total$mitoRatio <- Verity_total@meta.data$percent.mt / 100


View(Verity_total@meta.data)
```

## Initial data assessment

```{r}
png("Verity_Preliminary_Data_assessment.png", width=2000)
VlnPlot(Verity_total, features=c("nFeature_RNA","nCount_RNA","percent.mt", "percent.rp"), ncol=4, pt.size = 0.01)+ ggplot2::ggtitle("Preliminary Data assessment", subtitle= "Verity, unfiltered")
dev.off()
```

## Plot each of these respectively, showing trends in cell health

```{r}
#show mitochondrial proportion in reads
png("Verity_UMIs per cell vs.mitochondrial genes detected.png", width=1000)
FeatureScatter(Verity_total, feature1 = "nCount_RNA", feature2 = "percent.mt")+ggplot2::ggtitle("UMIs per cell vs. % mitochondrial genes detected")
dev.off()

png("Verity_UMIs_per_cell_vsribosomal_protein_genes_detected.png", width=1000)
#show ribosomal proportion in reads
FeatureScatter(Verity_total, feature1 = "nCount_RNA", feature2 = "percent.rp")+ggplot2::ggtitle("UMIs per cell vs. % ribosomal protein  genes detected")
dev.off()

png("Verity_ribosomal_protein_genes_detected_vsmitochondiral_genes_detected.png", width=1000)
#Ribosomal vs mitochondrial 
FeatureScatter(Verity_total, feature1 = "percent.rp", feature2 = "percent.mt")+ggplot2::ggtitle("% ribosomal protein  genes detected vs. % mitochondiral genes detected")
dev.off()
```

```{r}
#Show overall reads and gene counts for unfiltered data.
png("Verity_UMIs_per_cell_vs_number_of_genes.png", width=1000)
FeatureScatter(Verity_total, feature1 = "nCount_RNA", feature2="nFeature_RNA",raster=FALSE, pt.size = 0.05)+ ggplot2::geom_smooth(method="lm")+ ggplot2::ggtitle("UMIs per cell vs. number of genes ")
dev.off()
```

### Add metadata, adding sample identity

adapted from <https://youtu.be/p49seH2_i8Y?t=312>

```{r}
sampleLabs<-names(Verity_total@active.ident)

#FIXME change these to be treatment levels of experimental setup

#Assigning names to the samples to keep identity
#From Chat GPT
sample_detect <- case_when(
  str_detect(sampleLabs, "sample11") ~ "sample11",
  str_detect(sampleLabs, "sample1") ~ "sample1",
  str_detect(sampleLabs, "sample2") ~ "sample2",
  str_detect(sampleLabs, "sample5") ~ "sample5",
  str_detect(sampleLabs, "sample6") ~ "sample6",
  str_detect(sampleLabs, "sample9") ~ "sample9",
  TRUE ~ NA_character_
)
#
Verity_total@meta.data$sample<-sample_detect
Idents(object=Verity_total)<-"sample"
rm(sampleLabs, sample_detect)
```

### Save the whole data

```{r}
#Save the data object
save(Verity_total, file="./Rdata/Verity_total_labelled.RData")
```

### Create metadata variable to edit it without affecting core data

```{r}
# Rename columns from https://github.com/hbctraining/scRNA-seq/blob/master/lessons/04_SC_quality_control.md

#Create metadata variable to edit it without affecting core data
metadata_test<-Verity_total@meta.data

#Saving cell barcodes as metainfo
metadata_test$cells<-rownames(metadata_test)

metadata_test <- metadata_test %>%
    dplyr::rename(nUMI = nCount_RNA,
                  nGene = nFeature_RNA)
```

### Counts per sample

This shows over 300k cells for some samples, indicating that minimum
metrics must be set to remove junk.

```{r}
# Visualize the number of cell counts per sample with no filtering at all
png("Verity_Cell_counts_per_sample1.png", width=1500)
metadata_test %>% 
  	ggplot2::ggplot(aes(x=sample, fill=sample)) + 
  	geom_bar() +
  	theme_classic() +
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  	theme(plot.title = element_text(hjust=0.5, face="bold")) +
  	ggplot2::ggtitle("Cell counts per sample", subtitle="Verity, unfiltered")
dev.off()
```

## Setting a minimum gene count for quality control

```{r}
#Setting minimum feature count to filter cells with no genes UMIs vs. genes detected

metadata_test <- subset(Verity_total, subset= nFeature_RNA > 20)@meta.data
metadata_test <- metadata_test %>%
    dplyr::rename(nUMI = nCount_RNA,
                  nGene = nFeature_RNA)
```

```{r}
# Visualize the number of cell counts per sample with a minimum gene count set
png("Verity_Cell_counts_per_sample2.png", width=1000)
metadata_test %>% 
  	ggplot(aes(x=sample, fill=sample)) + 
  	geom_bar() +
  	theme_classic() +
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  	theme(plot.title = element_text(hjust=0.5, face="bold")) +
  	ggplot2::ggtitle("Cell counts per sample", subtitle="Verity, filtered to minimum 20 genes")
dev.off()
```

### UMI/ transcripts per cell

With line at 500 for ideal minimum

```{r}
# Visualize the number UMIs/transcripts per cell
png("Verity_UMI_transcripts_per_cell.png", width=1000)
metadata_test %>% 
  	ggplot(aes(color=sample, x=nUMI, fill= sample)) + 
  	geom_density(alpha = 0.2) + 
  	scale_x_log10() + 
  	theme_classic() +
  	ylab("Cell density") +
  	geom_vline(xintercept = 500)+
    ggplot2::ggtitle("UMI/transcripts per cell", subtitle="Verity, filtered to minimum 20 genes")
dev.off()
```

### Genes per cell

```{r}
# Visualize the distribution of genes detected per cell via histogram
png("Verity_Distribution_of_genes_per_cell1.png", width=1000)
metadata_test %>% 
  	ggplot(aes(color=sample, x=nGene, fill= sample)) + 
  	geom_density(alpha = 0.2) + 
  	theme_classic() +
  	scale_x_log10() + 
  	geom_vline(xintercept = 300)+
    ggplot2::ggtitle("Distribution of genes per cell", subtitle="Verity, filtered to minimum 20 genes")
dev.off()

# Visualize the distribution of genes detected per cell via boxplot
png("Verity_Distribution_of_genes_per_cell2.png", width=1000)
metadata_test %>% 
  	ggplot(aes(x=sample, y=log10(nGene), fill=sample)) + 
  	geom_boxplot() + 
  	theme_classic() +
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  	theme(plot.title = element_text(hjust=0.5, face="bold")) +
  	ggplot2::ggtitle("Distribution of genes per cell", subtitle="Verity, filtered to minimum 20 genes")
dev.off()
```

### UMI vs. genes detected

We want cells in top right

```{r}
#Some code commented out because it introduced infitine values with a log transform
# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs
png("Verity_UMIs_vs_genes_detected.png", width=2000)
metadata_test %>% 
  	ggplot(aes(x=nUMI, y=nGene, color=mitoRatio)) + 
  	geom_point() + 
	scale_colour_gradient(low = "gray90", high = "black") +
  	#stat_smooth(method=lm) +
  	scale_x_log10() +
  	scale_y_log10() +
  	theme_classic() +
  	geom_vline(xintercept = 500) +
  	geom_hline(yintercept = 250) +
  	facet_wrap(~sample) +
    ggplot2::ggtitle("UMIs vs. genes detected", subtitle = "Verity, minimum 20 genes")
dev.off()
```

### MitoRatio

We want data lower than 0.2

```{r}
# Visualize the distribution of mitochondrial gene expression detected per cell
png("Verity_Distribution_of_mitochondrial_gene_expression_per_cell.png", width=1000)
metadata_test %>% 
  	ggplot(aes(color=sample, x=mitoRatio, fill=sample)) + 
  	geom_density(alpha = 0.2) + 
  	scale_x_log10() + 
  	theme_classic() +
  	geom_vline(xintercept = 0.2)+
    ggplot2::ggtitle("Distribution of mitochondrial gene expression per cell", subtitle="Verity, filtered to minimum 20 genes")
dev.off()
```

```{r}
png("Verity_Repeat_mitoratio.png", width=1000)
FeatureScatter((subset(Verity_total, subset= nFeature_RNA > 20)), feature1 = "nFeature_RNA", feature2 = "percent.mt")
dev.off()
```

### Complexity

Should be above 0.8.

```{r}
# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI
png("Verity_Complexity_of_gene_expression_genes_per_UMI2.png", width=1000)
metadata_test %>%
  	ggplot(aes(x=log10GenesPerUMI, color = sample, fill=sample)) +
  	geom_density(alpha = 0.2) +
  	theme_classic() +
  	geom_vline(xintercept = 0.8)+
    ggplot2::ggtitle("Complexity of gene expression (genes per UMI)", subtitle="Verity, filtered to minimum 20 genes")
dev.off()
```

### Filtering metadata

```{r}
metadata_filtered<- metadata_test %>%
    filter(nUMI > 500, nGene >1100, percent.mt <20)
```

## Repeat the QC analysis

```{r}
# Visualize the number of cell counts per sample with a minimum gene count set
png("Verity_Cell_counts_per_sample2.png", width=1000)
metadata_filtered %>% 
  	ggplot(aes(x=sample, fill=sample)) + 
  	geom_bar() +
  	theme_classic() +
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  	theme(plot.title = element_text(hjust=0.5, face="bold")) +
  	ggplot2::ggtitle("Cell counts per sample", subtitle="Verity, filtered to minimum 0 transcripts, 300 genes and maVerum 20% mitochondrial gene content")
dev.off()

table(metadata_filtered$sample)
```

### UMI/ transcripts per cell

With line at 500 for ideal minimum

```{r}
# Visualize the number UMIs/transcripts per cell
png("Verity_UMI_transcripts_per_cell2.png", width=1000)
metadata_filtered %>% 
  	ggplot(aes(color=sample, x=nUMI, fill= sample)) + 
  	geom_density(alpha = 0.2) + 
  	scale_x_log10() + 
  	theme_classic() +
  	ylab("Cell density") +
  	geom_vline(xintercept = 500)+
    ggplot2::ggtitle("UMI/transcripts per cell", subtitle="Verity, filtered to minimum 0 transcripts, 300 genes and maVerum 20% mitochondrial gene content")
dev.off()
```

### Genes per cell

```{r}
# Visualize the distribution of genes detected per cell via histogram
png("Verity_Distribution_of_genes_per_cell3.png", width=1000)
metadata_filtered %>% 
  	ggplot(aes(color=sample, x=nGene, fill= sample)) + 
  	geom_density(alpha = 0.2) + 
  	theme_classic() +
  	scale_x_log10() + 
  	geom_vline(xintercept = 300)+
    ggplot2::ggtitle("Distribution of genes per cell", subtitle="Verity, filtered to minimum 0 transcripts, 300 genes and maVerum 20% mitochondrial gene content")
dev.off()

# Visualize the distribution of genes detected per cell via boxplot
png("Verity_Distribution_of_genes_per_cell4.png", width=1000)
metadata_filtered %>% 
  	ggplot(aes(x=sample, y=log10(nGene), fill=sample)) + 
  	geom_boxplot() + 
  	theme_classic() +
  	theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  	theme(plot.title = element_text(hjust=0.5, face="bold")) +
  	ggplot2::ggtitle("Distribution of genes per cell", subtitle="Verity, filtered to minimum 0 transcripts, 300 genes and maVerum 20% mitochondrial gene content")
dev.off()
```

### UMI vs. genes detected

We want cells in top right

```{r,fig.dim = c(8, 6)}
#Some code commented out because it introduced infitine values with a log transform
# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs
png("Verity_UMIs_vs_genes_detected2.png", width=1000)
metadata_filtered %>% 
  	ggplot(aes(x=nUMI, y=nGene, color=mitoRatio)) + 
  	geom_point() + 
	scale_colour_gradient(low = "gray90", high = "black") +
  	#stat_smooth(method=lm) +
  	scale_x_log10() +
  	scale_y_log10() +
  	theme_classic() +
  	geom_vline(xintercept = 500) +
  	geom_hline(yintercept = 250) +
  	facet_wrap(~sample) +
    ggplot2::ggtitle("UMIs vs. genes detected", subtitle = "Verity, filtered to minimum 0 transcripts, 300 genes and maVerum 20% mitochondrial gene content")
dev.off()
```

### MitoRatio

We want data lower than 0.2

```{r}
# Visualize the distribution of mitochondrial gene expression detected per cell
png("Verity_Distribution_of_mitochondrial_gene_expression_per_cell2.png", width=1000)
metadata_filtered %>% 
  	ggplot(aes(color=sample, x=mitoRatio, fill=sample)) + 
  	geom_density(alpha = 0.2) + 
  	scale_x_log10() + 
  	theme_classic() +
  	geom_vline(xintercept = 0.2)+
    ggplot2::ggtitle("Distribution of mitochondrial gene expression per cell", subtitle="Verity, filtered to minimum 0 transcripts, 300 genes and maVerum 20% mitochondrial gene content")
dev.off()
```

### Complexity

Should be above 0.8.

```{r}
# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI
png("Verity_Complexity_of_gene_expression_genes_per_UMI_2.png", width=1000)
metadata_filtered %>%
  	ggplot(aes(x=log10GenesPerUMI, color = sample, fill=sample)) +
  	geom_density(alpha = 0.2) +
  	theme_classic() +
  	geom_vline(xintercept = 0.8)+
    ggplot2::ggtitle("Complexity of gene expression (genes per UMI)", subtitle="Verity, filtered to minimum 0 transcripts, 300 genes and maVerum 20% mitochondrial gene content")
dev.off()
```

### Assign filters to data

```{r}
#filter out the cells with mitochondrial genes more than 5% and genes with more than .... genes as instructed by Nick
temp_meta<-Verity_total@meta.data
temp_meta <- temp_meta %>%
    dplyr::rename(nUMI = nCount_RNA,
                  nGene = nFeature_RNA)

Verity_total@meta.data<-temp_meta


Verity_filtered<- subset(Verity_total,subset= 
                              percent.mt <20 &
                              nUMI > 500 &
                              nGene >1100
                            )
rm(temp_meta, metadata_test, metadata_filtered)
```

### Gene-level filtering

Keeping genes which appear in more than 3 cells for statistical power.

```{r}

# Output a logical vector for every gene on whether the more than zero counts per cell
# Extract counts
counts <- GetAssayData(object = Verity_filtered, slot = "counts")

# Output a logical vector for every gene on whether the more than zero counts per cell
nonzero <- counts > 0

# Sums all TRUE values and returns TRUE if more than 3 TRUE values per gene
keep_genes <- Matrix::rowSums(nonzero) >= 3

# Only keeping those genes expressed in more than 10 cells
filtered_counts <- counts[keep_genes, ]

# Reassign to filtered Seurat object
Verity_filtered <- CreateSeuratObject(filtered_counts, meta.data = Verity_filtered@meta.data)
rm(filtered_counts, nonzero,counts, keep_genes)
```

### Saving object

```{r}
# Create .RData object to load at any time
save(Verity_filtered, file="./Rdata/Verity_predoublet.RData")
```

## Doublet finder for all samples

```{r}

#load in the filtered Verity object
#load("./Rdata/Verity_filtered.RData")

#adapted from https://youtu.be/p49seH2_i8Y , https://github.com/kpatel427/YouTubeTutorials/blob/5b3c795cecafb22f0e992da069eae2efd6b5cb95/singleCell_doublets.R , https://rpubs.com/kenneditodd/doublet_finder_example 

Verity.list <- SplitObject(Verity_filtered, split.by = "sample")

# Perform doublet detection on each sample using lapply
Verity.list <- lapply(Verity.list, function(sample) {
  print(paste0("Sample ",sample@meta.data$sample[1]))
  # Pre-process seurat object with standard seurat workflow
  sample <- SCTransform(sample)
  sample <- RunPCA(sample)
  
  # Find significant PCs
  stdv <- sample[["pca"]]@stdev
  sum.stdv <- sum(sample[["pca"]]@stdev)
  percent.stdv <- (stdv / sum.stdv) * 100
  cumulative <- cumsum(percent.stdv)
  co1 <- which(cumulative > 90 & percent.stdv < 5)[1]
  co2 <- sort(which((percent.stdv[1:length(percent.stdv) - 1] -
                       percent.stdv[2:length(percent.stdv)]) > 0.1),
              decreasing = TRUE)[1] + 1
  min.pc <- min(co1, co2)
  
  # Finish pre-processing
  sample <- RunUMAP(sample, dims = 1:min.pc)
  sample <- FindNeighbors(object = sample, dims = 1:min.pc)              
  sample <- FindClusters(object = sample, resolution = 0.1)
  
  # pK identification (no ground-truth)
  sweep.list <- paramSweep_v3(sample, PCs = 1:min.pc, sct = TRUE)
  sweep.stats <- summarizeSweep(sweep.list)
  bcmvn <- find.pK(sweep.stats)
  
  # Optimal pK is the max of the bomodality coefficient (BCmvn) distribution
  bcmvn.max <- bcmvn[which.max(bcmvn$BCmetric),]
  optimal.pk <- as.numeric(bcmvn.max$pK)

  # Homotypic doublet proportion estimate
  annotations <- sample@meta.data$seurat_clusters
  homotypic.prop <- modelHomotypic(annotations) 
  nExp.poi <- round(0.087 * nrow(sample@meta.data))
  nExp.poi.adj <- round(nExp.poi * (1 - homotypic.prop))
  
  # Run DoubletFinder
  sample <- doubletFinder_v3(seu = sample, 
                             PCs = 1:min.pc, 
                             pK = optimal.pk,
                             nExp = nExp.poi.adj, 
                             sct = TRUE, 
                             pN=0.25)
  
  return(sample)
  
})

#Rename the columns
Verity.list <- lapply(Verity.list, function(sample) {
  doublet_col_index <- which(grepl("DF.classifications_", colnames(sample@meta.data)))
  sample$doublet_finder <- sample@meta.data[doublet_col_index]
  sample@meta.data[doublet_col_index]<-NULL
  return(sample)
})

#subset data by singlet status
Verity.list.singlets <- lapply(Verity.list, function(sample) {
  sample<- subset(sample, subset= doublet_finder == 'Singlet')
  return(sample)
  })

```

```{r}
#merge the data back together
Ver_singlets_merged <- Merge_Seurat_List(list_seurat = Verity.list.singlets)
rm(Verity.list.singlets)
```

### Saving object

```{r}
# Create .RData object to load at any time
save(Ver_singlets_merged, file="Rdata/Ver_singlets_merged.RData")

```

# Within dataset integration

### Make metadata for treatment

```{r}
sampleLabs<-names(Ver_singlets_merged@active.ident)

#FIXME change these to be treatment levels of experimental setup

#Assigning names to the samples to keep identity
#From Chat GPT
treat_detect <- case_when(
  str_detect(sampleLabs, "sample11") ~ "AGEING",
  str_detect(sampleLabs, "sample1") ~ "NBH",
  str_detect(sampleLabs, "sample2") ~ "NBH",
  str_detect(sampleLabs, "sample5") ~ "ME7",
  str_detect(sampleLabs, "sample6") ~ "ME7",
  str_detect(sampleLabs, "sample9") ~ "AGEING",
  TRUE ~ NA_character_
)
#
Ver_singlets_merged@meta.data$treatment<-treat_detect

#FIXME may not be needed if the integration workflow specifies what to consider anyway
Idents(object=Ver_singlets_merged)<-"treatment"
rm(sampleLabs, treat_detect)
```

```{r}
Ver_ME7_NBH<-subset(Ver_singlets_merged, subset= treatment!="AGEING")
table(Ver_ME7_NBH@meta.data$treatment)
```


```{r}
# adapted from https://satijalab.org/seurat/articles/integration_introduction.html

#FIXME set the RNA assay as active
DefaultAssay(Ver_ME7_NBH) <- "RNA"

# split the dataset into a list of three seurat objects (ME7, NBH, AGEING)
Ver_list<-SplitObject(Ver_ME7_NBH, split.by = "treatment")
rm(Ver_ME7_NBH)
gc()


# normalize and identify variable features for each dataset independently
Ver_list <- lapply(X = Ver_list, FUN = function(x) {
    x <- NormalizeData(x)
    x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
})

# select features that are repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = Ver_list,verbose = TRUE)
```

### RPCA options

from [<https://satijalab.org/seurat/articles/integration_rpca.html>]

```{r}
gc()
#Perform PCA on the data individually before integration
Ver_list <- lapply(X = Ver_list, FUN = function(x) {
    x <- ScaleData(x, features = features, verbose = TRUE)
    x <- RunPCA(x, features = features, verbose = TRUE)
})


#Use RPCA
Verity.anchors <- FindIntegrationAnchors(object.list = Ver_list, anchor.features = features, verbose=TRUE, reduction='rpca')

# this command creates an 'integrated' data assay
Verity.combinedNBHME7 <- IntegrateData(anchorset = Verity.anchors, verbose=TRUE)
```

```{r}
# specify that we will perform downstream analysis on the corrected data note that the
# original unmodified data still resides in the 'RNA' assay
DefaultAssay(Verity.combinedNBHME7) <- "integrated"

# Run the standard workflow for visualization and clustering
Verity.combinedNBHME7 <- ScaleData(Verity.combinedNBHME7, verbose = FALSE)
Verity.combinedNBHME7 <- RunPCA(Verity.combinedNBHME7, npcs = 30, verbose = FALSE)
ElbowPlot(Verity.combinedNBHME7, ndims=30)+ggtitle("Elbowplot of Integrated Verity data", subtitle = "RunPCA npcs=30, RPCA workflow")

#20 PCs seem to cover the variability
Verity.combinedNBHME7 <- RunUMAP(Verity.combinedNBHME7, reduction = "pca", dims = 1:20)
Verity.combinedNBHME7 <- FindNeighbors(Verity.combinedNBHME7, reduction = "pca", dims = 1:20)
Verity.combinedNBHME7 <- FindClusters(Verity.combinedNBHME7, resolution = c(0.2,0.3,0.5,0.7,1))

#cyclechange resolution number in group.by to see difference in clusters
DimPlot(Verity.combinedNBHME7, reduction = 'umap', label = TRUE, repel = TRUE, raster=F)+ggtitle("Integrated Verity data, labelled by cluster numbers", subtitle="RPCA,Clustering resolution 1, 20 PCs used")

#set the idents to 0.5
Verity.combinedNBHME7@active.ident<-Verity.combinedNBHME7@meta.data$integrated_snn_res.0.5
levels(Verity.combinedNBHME7)

#Save the object
save(Verity.combinedNBHME7,file="Rdata/Verity.self_integrated_RPCA_NBHME7.Rdata")
```

```{r}
# Visualization
p1 <- DimPlot(Verity.combinedNBHME7, reduction = "umap", split.by = "treatment", raster=FALSE)+ ggtitle("Integrated Verity data, split by treatment", subtitle="RPCA,Clustering resolution 1, 20 PCs used")

#Check for sample batch effects (shouldn't see this in an integrated dataset). The colou pallete hides sample11 because it covers everything

# dimplotcolours=c(
#   rgb(0.53, 0.81, 0.95, 0.5),
#   'NA',
#   #rgb(0.23, 0.51, 0.75, 0.5), #uncomment to give sample 11 colour, but this covers most of the data
#   rgb(0.95, 0.27, 0.14, 0.5),
#   rgb(0.61, 0.09, 0.78, 0.5),
#   rgb(0.44, 0.83, 0.15, 0.5),
#   rgb(0.92, 0.67, 0.12, 0.5),
#   rgb(0.03, 0.65, 0.40, 0.5)
# )
# p2 <- DimPlot(Verity.combinedNBHME7, reduction = "umap", group.by = "sample", raster=FALSE +scale_color_manual(values = dimplotcolours))

#This plot would be to label by cell type, not useable as I haven't used singleR yet
# p3 <- DimPlot(Verity.combinedNBHME7, reduction = "umap", group.by = "seurat_annotations", label = TRUE,repel = TRUE, raster=FALSE)


#show the plots
p1 #+ p2 +p3
```

```{r}
DefaultAssay(Verity.combinedNBHME7)<-"RNA"

#Check for a gene of interest in the data's geneset
Gene_Names<-Verity.combinedNBHME7@assays[["RNA"]]@counts@Dimnames[[1]]
filtered_gene_names<-Gene_Names[!grepl("^\\d", Gene_Names)]
filtered_gene_names[grep("^Slc1a2", filtered_gene_names)]

#try to identify astrocytes  with genes (Aldh1l1, Syp, Csf1r,Tmem119, Map2, Gfap)

astrocyte_genes<-c("Aldh1l1","Gfap","Slc1a2")

FeaturePlot(Verity.combinedNBHME7,features="Nalcn", raster=F)+ggtitle("Integrated Verity data, labelled with astrocyte gene markers", subtitle="RPCA,Clustering resolution 1, 20 PCs used")
#+scale_colour_gradientn(colours = rev(brewer.pal(n = 11, name = "Spectral"))) + ggtitle("ALDH1 for astrocytes")
```

## Investigate astrocytes

```{r}

# Convert cluster names to character
Idents(Verity.combinedNBHME7) <- as.character(Idents(Verity.combinedNBHME7))
VlnPlot(Verity.combinedNBHME7, features = "Gfap")

#Subset out astrocytes
Ver_astrocytes<-subset(Verity.combinedNBHME7, idents=c('3','27','25'))


#find clustered astrocyte markers, differences in astrocyte populations

DefaultAssay(Ver_astrocytes)<-'RNA'
astrocyte.markers <- FindMarkers(Ver_astrocytes, ident.1 = 3, min.pct = 0.25, verbose = TRUE, test.use = "DESeq2")
head(astrocyte.markers, n = 6)
save(astrocyte.markers, file="astrocyte.markers.RData")
```


```{r}
#Seeing what genes are most strongly expressed or not expressed (with high confidence) in the supposed astrocyte cluster
astrocyte_conserved_markers<-FindConservedMarkers(Verity.combinedNBHME7, ident.1 = 3, grouping.var = "treatment", verbose = T,test.use = "DESeq2")
#https://github.com/brandonyph/Seurat_Integration_Introduction#chapter-2---identify-conserved-cell-type-markers:~:text=Chapter%202%20%2D%20Identify%20conserved%20cell%20type%20markers
save(astrocyte_conserved_markers, file="astrocyte_conserved_markers.RData")

```


```{r}
#adapted from https://www.youtube.com/watch?v=p49seH2_i8Y&t=717s&ab_channel=LiquidBrainBioinformatics
library(ComplexHeatmap)
heatmapdf <- astrocyte.markers[1:25,]
row_ha = rowAnnotation("A1" = anno_barplot(heatmapdf$pct.1),
                       "Others"= anno_barplot(heatmapdf$pct.2),
                       width = unit(10, "cm"))

ht0 <- Heatmap(heatmapdf$avg_log2FC,
                name = "Log2FC",
                cluster_rows = TRUE, 
                row_labels = rownames(heatmapdf), 
                right_annotation = row_ha,
                width = unit(1, "cm"),
               column_title ="DEGs of overall astrocytes cluster compared to the entire dataset (min.pct = 0.25, cluster 3 of Verity data" )

ht0
```


```{r}
#Getting markers of cluster3 (main astrocytes cluster)
#Filter the gene list of DEGS that are most strongly expressed in cluster3 by positive log2FC
positive_astrocyte_conserved<-subset(astrocyte_conserved_markers, NBH_avg_log2FC>0)

#Sort the list in descending log2FC and ascending pvalues regarding NBH treatment
positive_astrocyte_conserved<-positive_astrocyte_conserved[order(-positive_astrocyte_conserved$NBH_avg_log2FC, positive_astrocyte_conserved$NBH_p_val), ]

#Save the df with a new name, save the gene names as an object, remove the old object and view the top 6 genes (lowest pvalue and ighes log2FC)
positive_astrocyte_conserved_df<-positive_astrocyte_conserved
positive_astrocyte_conserved_genes<-rownames(positive_astrocyte_conserved)
rm(positive_astrocyte_conserved)
positive_astrocyte_conserved_genes[1:6]

#Save the file
write.csv(positive_astrocyte_conserved_df, file = "Supposed_astrocyte_markers.csv")

#Show these top genes on the UMAP
DefaultAssay(Verity.combinedNBHME7)<-"RNA"
FeaturePlot(Verity.combinedNBHME7,features=positive_astrocyte_conserved_genes[1:6], raster=F)+ggtitle("Integrated Verity data, labelled with cluster 3's strongest markers", subtitle="RPCA,Clustering resolution 1, 20 PCs used")
DefaultAssay(Verity.combinedNBHME7)<-"integrated"
```

```{r}
#trying to plot this on the same scale of colour, but it's changing the scale
library(gridExtra)

plot_title <- "Integrated Verity data, labelled with cluster 3's strongest markers"
subtitle <- "RPCA, Clustering resolution 1, 20 PCs used"

# Create a list to store the plots
plot_list <- list()
color_range<-c(0,5)
# Loop over the selected genes and create individual plots
for (gene in positive_astrocyte_conserved_genes[1:6]) {
    plot <- FeaturePlot(Verity.combinedNBHME7, features = gene, raster = FALSE)+scale_color_gradient(limits = color_range) +
        scale_fill_gradient(limits = color_range) 
    plot_list[[gene]] <- plot
}

# Arrange the plots in a grid layout
grid_arrange <- do.call(grid.arrange, c(plot_list, ncol = 3))

# Display the grid of plots
grid_arrange<-grid_arrange

```


```{r}
#subset, then cluster? Or add Slota first then do this analysis?
DefaultAssay(Ver_astrocytes)<-"integrated"

# Run the standard workflow for visualization and clustering
Ver_astrocytes <- ScaleData(Ver_astrocytes, verbose = FALSE)
Ver_astrocytes <- RunPCA(Ver_astrocytes, npcs = 30, verbose = FALSE)
ElbowPlot(Ver_astrocytes, ndims=30)+ggtitle("Elbowplot of Integrated Verity data", subtitle = "RunPCA npcs=30, RPCA workflow")

#20 PCs seem to cover the variability
Ver_astrocytes <- RunUMAP(Ver_astrocytes, reduction = "pca", dims = 1:20)
Ver_astrocytes <- FindNeighbors(Ver_astrocytes, reduction = "pca", dims = 1:20)
Ver_astrocytes <- FindClusters(Ver_astrocytes, resolution = c(0.2,0.3,0.5,0.7,1))

#cyclechange resolution number in group.by to see difference in clusters
DimPlot(Ver_astrocytes, reduction = 'umap', label = TRUE, repel = TRUE, raster=F)+ggtitle("Integrated Verity data's astrocytes, labelled by treatment", subtitle="13 clusters")

#set the idents to 0.5
Ver_astrocytes@active.ident<-Ver_astrocytes@meta.data$integrated_snn_res.0.5
levels(Ver_astrocytes)

DefaultAssay(Ver_astrocytes)<-'RNA'

#set identities to subclusters
Idents(Ver_astrocytes) <- as.character(Idents(Ver_astrocytes))

astrocyte_subcluster.markers <- FindMarkers(Ver_astrocytes, ident.1 = 0, min.pct = 0.25, verbose = TRUE, test.use = "DESeq2")

#by treatment
Ver_astrocytes@active.ident<-as.factor(Ver_astrocytes$treatment)
astrocyte_treatment.markers <- FindMarkers(Ver_astrocytes, ident.1 = 'NBH', min.pct = 0.25, verbose = TRUE, test.use = "DESeq2")

#Sort the list in descending log2FC and ascending pvalues
astrocyte_treatment.markers<-astrocyte_treatment.markers[order(-astrocyte_treatment.markers$avg_log2FC, astrocyte_treatment.markers$p_val), ]
#Save the file
write.csv(astrocyte_treatment.markers, file = "astrocyte_treatment.markers.csv")

save(astrocyte_treatment.markers, file="astrocyte_treatment.markers.RData")
```

